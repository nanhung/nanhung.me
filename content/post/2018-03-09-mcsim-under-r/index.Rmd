---
title: 'MCSim under R'
summary: Run GNU MCSim (under R) in Windows system
authors:
- admin
date: "2018-03-09"
output:
  blogdown::html_page:
    toc: true
    toc_depth: 2
projects: [PBPK]
categories: [software]
tags: [mcsim, R]

# Featured image
# To use, add an image named `featured.jpg/png` to your page's folder.
# Placement options: 1 = Full column width, 2 = Out-set, 3 = Screen-width
# Focal point options: Smart, Center, TopLeft, Top, TopRight, Left, Right, BottomLeft, Bottom, BottomRight  
# image:
#  placement: 2
#  preview_only: true
#  focal_point: 'TopRight'
#  caption: 'Image credit: [**Unsplash**](https://unsplash.com/photos/CpkOjOcXdUY)'

---

```{r setup, include=FALSE}
knitr::opts_chunk$set(eval = T)
```

{{% alert note %}}
<strong>**The post was updated on `r Sys.Date()` under `r sessioninfo::os_name()`.**</strong>
{{% /alert %}}

# Introduction

Using **GNU MCSim** under Windows is more complicated than the Unix-like System, such as macOS and Linux. Also, it does not provide the function to analyze and visualize the output result. Therefore, I write this post to demo how to run **GNU MCSim** under Windows OS and conduct the follow-up analysis with R. This exercise was sourced from the file [**MCSim under R**](https://www.gnu.org/software/mcsim/mcsim_under_R.zip) in [**GNU MCSim**](https://www.gnu.org/software/mcsim/). 

In this post, I used **Rtools** (v3.5) which has some essential set of Unix/Linux tools to conduct the model compilation. Also, the **GNU MCSim** (v6.1.0) is used to do the following modeling and simulation works. The portable version are put in my GitHub repo (https://github.com/nanhung/MinGM)

```{r}
wd <- getwd()
url <- "https://github.com/nanhung/MinGM/archive/v6.1.0.zip"
tf <- tempfile()
download.file(url, tf, mode = "wb")
unzip(zipfile = tf, exdir = wd)
```

If you have installed `devtools` you can use `devtools::find_rtools()` to check the avaliable of Rtools.

```{R}
devtools::find_rtools()
```

Also, we need to chek the Rtools is in the PATH by using 

```{R}
Sys.getenv("PATH")
```

If you can not find the Rtools in the PATH. such as, `c:\\Rtools\\bin` and  `c:\\Rtools\\mingw_64\\bin`. You will need to manually add it as follow,

```{R}
Sys.setenv(PATH = paste("c:\\Rtools\\bin", Sys.getenv("PATH"), sep=";"))
Sys.setenv(PATH = paste("c:\\Rtools\\mingw_64\\bin", Sys.getenv("PATH"), sep=";"))
```

Then, use following command to check the function.

```{R}
Sys.which("gcc")
```

```{r}
Sys.which("make")
```

## Create GNU MCSim program

The following steps is used to generate the executable program (`mod.exe`) that can traslate the format of model code to C. 

```{r echo=T, results='hide'}
libSBML = "" # libSBML = "-lsbml" 
# uncomment and execute if you have and want to use libSBML.

# create mod.exe in "mod" folder
system(paste("gcc -o MinGM-6.1.0/mod.exe MinGM-6.1.0/mod/*.c ", libSBML, sep = "")) 
```

**NOTE:** In this case, we don't need to load libSBML. Therefore, check the `config.h` file in mod folder. We can see the line 26 in the config.h file like [THIS](https://github.com/rbind/nanhung.me/blob/master/content/post/mod/config.h). The `#define HAVE_LIBSBML 1` had been disabled. It can prevent the problem when compile to the mod.exe file. (Thanks **Yu-Sheng Lin** for provding this issue; Mar. 23, 2018).

Finally, check if we successfully generate the program `mod.exe`.

```{r}
file.exists("MinGM-6.1.0/mod.exe")
```

If everything is going well, we can move on to next section.

# R package **deSolve** solution

## Solve ODE in pure R

This section is a demo of solving the ODE in R environment with **deSolve** package.

```{r}
# Load deSolve package
library(deSolve)
```

```{r}
# Create the ODE function based on the **deSolve** format
model <- function(t, Y, parameters) {
  with (as.list(parameters), {
    dy1 = -k1*Y[1] + k2*Y[2]*Y[3];
    dy3 = k3*Y[2]*Y[2];
    dy2 = -dy1 - dy3;
    list(c(dy1, dy2, dy3));
    })
}
jac <- function (t, Y, parameters) {
  with (as.list(parameters), {
       PD[1,1] <- -k1;
       PD[1,2] <- k2*Y[3];
       PD[1,3] <- k2*Y[2];
       PD[2,1] <- k1;
       PD[2,3] <- -PD[1,3];
       PD[3,2] <- k3*Y[2];
       PD[2,2] <- -PD[1,2] - PD[3,2];

       return(PD) 
    }) 
}
```

```{r}
# Define the parameter values and some conditions
parms <- c(k1 = 0.04, k2 = 1e4, k3=3e7) # parameter values
Y <- c(y1 = 1.0, y2 = 0.0, y3 = 0.0) # Initial conditions
times  <- c(0.04, 0.4*10^(0:11)) # Time steps
PD <- matrix(nrow = 3, ncol = 3, data = 0)
```

```{r}
# Solve ODE 
out.1 <- ode(Y, times, model, parms = parms, jacfunc = jac)
head(out.1)
```

```{r}
# Visualization
plot(out.1,type="b",log="x")
```

## Use **deSolve** with **GNU MCSim** model file

Here, we want to use model code that was based on the GNU MCSim format. The model code look like following format,

```
##################
## simple.model ##
##################

States = {y0, y1, y2};
Outputs = {yout};

# Parameters
k1 = 1;
k2 = 1;
k3 = 1;

Dynamics {

  dt(y0) = -k1 * y0 + k2 * y1 * y2; 
  dt(y2) =  k3 * y1 * y1; 
  dt(y1) = -dt(y0) - dt(y2);

  yout = y0 + y1 + y2;

} 

Events {
  y0 = 1;
}

Roots { # here we need inlining, otherwise 'gout' will not be understood 
  Inline ( gout[0] = y[0] - 0.5; );
}

End.
```

First, we need to create model script that is based on C (`simple.model.c`) and generate initialization file (`simple.model_inits.R`). 

```{r echo=T, results='hide'}
system("MinGM-6.1.0/mod.exe -R simple.model simple.model.c") 
```

```{r echo=T, results='hide'}
# create simple.model.o and simple.model.dll files
system ("R CMD SHLIB simple.model.c") 

# load simple.model.dll
dyn.load(paste("simple.model", .Platform$dynlib.ext, sep="")) 
```

Note, the compile the GNU MCSim model, needs to be done each time you modify the model.

```{R}
source ("simple.model_inits.R")

# define parameter values
parms_init <- initParms () 

# define initial state values
Y_init <- initStates (parms) 

# set output times, time 0 must be given
times <- c(0, 4e-1, 4e+0, 4e+1, 4e+2, 4e+3, 4e+4, 4e+5, 4e+6, 4e+7, 4e+8, 4e+9)
```


```{r}
out.2.1 <- ode(Y_init, times, func = "derivs", parms = parms_init, 
               jacfunc = "jac", dllname = "simple.model", 
               initfunc = "initmod", nout = 1, outnames = "Sum")

plot(out.2.1, log="x", type="b")
```

{{% alert note %}}
We can't find any change in the dynamic process. It is due to the all initial value equal to 0.  
{{% /alert %}}


```{r}
parms_init
Y_init
```


### Parameters and initial values

Since the parameters and initial state values should define before simulation, we need to use the following code to assign them.

```{R}
# Define the parameters and initial values
parms <- c(k1 = 0.04, k2 = 1e4, k3=3e7) 
Y <- c(y0 = 1.0, y1 = 0.0, y2 = 0.0)

# Use the defined parameters and initial values
out.2.2 <- ode(Y, times, func = "derivs", parms = parms,
               dllname = "simple.model", initfunc = "initmod",
               nout = 1, outnames = "Sum")

# Here is the output data frame
head(out.2.2)

# Plotting
plot(out.2.2, log="x", type="b")
```

# **GNU MCSim** solution

Here we want to use GNU MCSim to solve ODE. In this part, we need to have the input file (`simple.in`) in the working directory. The input file can define the initial and parameter values, respectively. Also,we need to set the output time steps and intervals. The source code looks like this:

```
###############
## simple.in ##
###############

Simulation {

  # Initial value
  y0 = 1;

  # Parameters
  k1 = 0.04;
  k2 = 1e4;
  k3 = 3e7;

  Print (y0, y1, y2, yout, 4e-1, 4e+0, 4e+1, 4e+2, 4e+3, 4e+4, 4e+5, 4e+6, 4e+7, 4e+8, 
         4e+9);
}

End.
```

The following step compile the `simple.model` file and create the executable program named `mcsim.simple.model.exe`. 

```{R}
system("MinGM-6.1.0/mod.exe simple.model simple.model.c") 
```

Unlike above exercice, we need to remove the -R flag that can only create c file. Then, compile the `simple.model.c` to `mcsim.simple.model.exe`. 

```{R, warning=FALSE}
system("gcc -O3 -I.. -I MinGM-6.1.0/sim -o mcsim_simple.model.exe simple.model.c MinGM-6.1.0/sim/*.c -lm ")

# run!
system("./mcsim_simple.model.exe simple.in")

# the output file is called out by default, load it
out.3 <- read.delim("sim.out", skip = 2)
head (out.3)

# look
par(mfrow=c(2,2))
plot(out.3[,1], out.3[,2], log="x",type="b", xlab = "time", ylab = "", main = "y0")
plot(out.3[,1], out.3[,3], log="x",type="b", xlab = "time", ylab = "", main = "y1")
plot(out.3[,1], out.3[,4], log="x",type="b", xlab = "time", ylab = "", main = "y2")
plot(out.3[,1], out.3[,5], log="x",type="b", xlab = "time", ylab = "", main = "yout")
```

# Session info

```{r}
sessionInfo()
```

