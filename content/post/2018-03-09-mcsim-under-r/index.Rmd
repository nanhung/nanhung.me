---
title: 'MCSim under R'
summary: Run GNU MCSim (under R) in Windows system
authors:
- admin
date: "2018-03-09"
output:
  blogdown::html_page:
    toc: true
    toc_depth: 2
projects: [PBPK]
categories: [software]
tags: [mcsim, R]

# Featured image
# To use, add an image named `featured.jpg/png` to your page's folder.
# Placement options: 1 = Full column width, 2 = Out-set, 3 = Screen-width
# Focal point options: Smart, Center, TopLeft, Top, TopRight, Left, Right, BottomLeft, Bottom, BottomRight  
# image:
#  placement: 2
#  preview_only: true
#  focal_point: 'TopRight'
#  caption: 'Image credit: [**Unsplash**](https://unsplash.com/photos/CpkOjOcXdUY)'

---

```{r setup, include=FALSE}
knitr::opts_chunk$set(eval = T)
```

{{% alert note %}}
<strong>**The post was updated on `r Sys.Date()` under `r sessioninfo::os_name()`.**</strong>
{{% /alert %}}

# Prerequisites

- R
- RStudio
- Rtools
- GNU MCSim (portable version; https://github.com/nanhung/MCSim_under_R)

This exercise was sourced from the file [**MCSim under R**](https://www.gnu.org/software/mcsim/mcsim_under_R.zip) in [**GNU MCSim**](https://www.gnu.org/software/mcsim/). The version of **Rtools** is 3.5 and **GNU MCSim** is 6.1.0.

If you have installed `devtools` you can use `devtools::find_rtools()` to check the avaliable of Rtools.

```{R}
devtools::find_rtools()
```

Also, we need to chek the Rtools is in the PATH by using 

```{R}
Sys.getenv("PATH")
```

If you can not find the Rtools in the PATH. such as, `c:\\Rtools\\bin` and  `c:\\Rtools\\mingw_64\\bin`. You will need to manually add it as follow,

```{R}
Sys.setenv(PATH = paste("c:\\Rtools\\bin", Sys.getenv("PATH"), sep=";"))
Sys.setenv(PATH = paste("c:\\Rtools\\mingw_64\\bin", Sys.getenv("PATH"), sep=";"))
```

Then, use following command to check the function.

```{R}
Sys.which("gcc")
```

```{r}
Sys.which("make")
```

## Create GNU MCSim program

The following steps can compile the `simple.model` file (sourced from **GNU MCSim**) and create the executable program. The testing model `simple.model` file looks like this:

```
#------------------------------------------------------------------------------
# the deSolve example model (simple.model)
#------------------------------------------------------------------------------

States = {y0, y1, y2};

Outputs = {yout};

# Parameters
k1 = 1;
k2 = 1;
k3 = 1;

Dynamics {

  dt(y0) = -k1 * y0 + k2 * y1 * y2; 
  dt(y2) =  k3 * y1 * y1; 
  dt(y1) = -dt(y0) - dt(y2);

  yout = y0 + y1 + y2;

} # End of Dynamics

Events {
  y0 = 1;
}

Roots { # here we need inlining, otherwise 'gout' will not be understood 
  Inline ( gout[0] = y[0] - 0.5; );
}

End.
```


{{% alert warning %}}
Make sure that the `simple.model` and `mod` folder are put in the working directory!
{{% /alert %}}

**NOTE:** In this case, we don't need to load libSBML. Therefore, check the `config.h` file in mod folder. We can see the line 26 in the config.h file like [THIS](https://github.com/rbind/nanhung.me/blob/master/content/post/mod/config.h). The `#define HAVE_LIBSBML 1` had been disabled. It can prevent the problem when compile to the mod.exe file. (Thanks **Yu-Sheng Lin** for provding this issue; Mar. 23, 2018).

```{r echo=T, results='hide'}
libSBML = "" # libSBML = "-lsbml" 
# uncomment and execute if you have and want to use libSBML.

# create mod.exe in "mod" folder
system(paste("gcc -o ./mod/mod.exe ./mod/*.c ", libSBML, sep = "")) 
```

Use model file to check it works.

```{R}
mName <- "simple.model"
```

If everything is going well, we can move on to next section.

# R package **deSolve** solution

## Solve ODE in pure R

```{r}
# Load deSolve package
library(deSolve)
```

```{r}
# Create the ODE function based on the **deSolve** format
model <- function(t, Y, parameters) {
  with (as.list(parameters), {
    dy1 = -k1*Y[1] + k2*Y[2]*Y[3];
    dy3 = k3*Y[2]*Y[2];
    dy2 = -dy1 - dy3;
    list(c(dy1, dy2, dy3));
    })
}
jac <- function (t, Y, parameters) {
  with (as.list(parameters), {
       PD[1,1] <- -k1;
       PD[1,2] <- k2*Y[3];
       PD[1,3] <- k2*Y[2];
       PD[2,1] <- k1;
       PD[2,3] <- -PD[1,3];
       PD[3,2] <- k3*Y[2];
       PD[2,2] <- -PD[1,2] - PD[3,2];

       return(PD) 
    }) 
}
```

```{r}
# Define the parameter values and some conditions
parms <- c(k1 = 0.04, k2 = 1e4, k3=3e7) # parameter values
Y <- c(y1 = 1.0, y2 = 0.0, y3 = 0.0) # Initial conditions
times  <- c(0.04, 0.4*10^(0:11)) # Time steps
PD <- matrix(nrow = 3, ncol = 3, data = 0)
```

```{r}
# Solve ODE 
out.1 <- ode(Y, times, model, parms = parms, jacfunc = jac)
head(out.1)
```

```{r}
# Visualization
plot(out.1,type="b",log="x")
```

## Use **deSolve** with **GNU MCSim** model file

```{r echo=T, results='hide'}
# Create .c file and use -R to generate "simple.model_inits.R" initialization file
system(paste("./mod/mod.exe -R ", mName, " ", mName, ".c", sep = "")) 
```

```{r echo=T, results='hide'}
# compile the MCSim executable, needs to be done each time you modify the model
system (paste0("R CMD SHLIB ", mName, ".c")) # create .o and .dll files
dyn.load(paste(mName, .Platform$dynlib.ext, sep="")) # load simple.model.dll
```

```{R}
source ("simple.model_inits.R")

parms_init <- initParms () # define parameter values
Y_init <- initStates (parms) # define initial state values

# set output times, time 0 must be given
times <- c(0.04, 0.4*10^(0:10))

out.2.1 <- ode(Y_init, times, func = "derivs", parms = parms_init, 
               jacfunc = "jac", dllname = "simple.model", 
               initfunc = "initmod", nout = 1, outnames = "Sum")

plot(out.2.1, log="x", type="b")
```

{{% alert note %}}
We can't find any change in the dynamic process. It is due to the all initial value equal to 0.  
{{% /alert %}}

### Parameters and initial values

```{R}
# Define the parameters and initial values
parms <- c(k1 = 0.04, k2 = 1e4, k3=3e7) 
Y <- c(y0 = 1.0, y1 = 0.0, y2 = 0.0)

# Use the defined parameters and initial values
out.2.2 <- ode(Y, times, func = "derivs", parms = parms,
               dllname = mName, initfunc = "initmod",
               nout = 1, outnames = "Sum")

# Here is the output data frame
head(out.2.2)

# Plotting
plot(out.2.2, log="x", type="b")
```

# **GNU MCSim** solution

In this part, we need to put `simple.in` file in the working directory. The input file can define the initial and parameter values, respectively. Also,we need to set the output time steps and intervals. The source code looks like this:

```
#------------------------------------------------------------------------------
# the deSolve example model run with GNU MCSim
#------------------------------------------------------------------------------

Simulation {

  # Initial value
  y0 = 1;

  # Parameters
  k1 = 0.04;
  k2 = 1e4;
  k3 = 3e7;

  Print (y0, y1, y2, yout, 0.04, 4e-1, 4e+0, 4e+1, 4e+2, 4e+3, 4e+4, 4e+5, 4e+6, 4e+7, 4e+8, 
         4e+9);
}

End.
```

The following step compile the `simple.model` file and create the executable program named `mcsim.simple.model.exe`. 

```{R}
# set the name of your model
mName = "simple.model"
```

Your model executable can be linked with the GNU Scientific Library (GSL, recommended). If you have GSL installed the directives `#define HAVE_LIBGSL 1` and `#define HAVE_LIBGSLCBLAS 1` should appear in the `config.h` file, in the directory above this one. If it does not, put them in, alone at the beginning of a line. If you do NOT have libGSL, those directives should NOT appear in that file. If they do, delete them.

```{R}
libGSL = "" # libGSL = "-lgsl -lgslcblas" 
# uncomment and execute if you have the GNU Scientific Library

system(paste("./mod/mod.exe ", mName, " ", mName, ".c", sep = "")) 
# Unlike above exercice, you need to remove the -R flag that can only create c file.
```

Compile the `simple.model.c` to `mcsim.simple.model.exe`. 

```{R, warning=FALSE}
system(paste("gcc -O3 -I.. -I./sim -o mcsim_", mName, ".exe ", mName, ".c ./sim/*.c -lm ", sep = ""))

# run the simulation input file
# put its name here
simName = "simple.in"

# run!
system(paste("./mcsim_", mName, ".exe ", simName, sep = ""))

# the output file is called out by default, load it
out.3 <- read.delim("sim.out", skip = 2)
head (out.3)

# look
par(mfrow=c(2,2))
plot(out.3[,1], out.3[,2], log="x",type="b", xlab = "time", ylab = "", main = "y0")
plot(out.3[,1], out.3[,3], log="x",type="b", xlab = "time", ylab = "", main = "y1")
plot(out.3[,1], out.3[,4], log="x",type="b", xlab = "time", ylab = "", main = "y2")
plot(out.3[,1], out.3[,5], log="x",type="b", xlab = "time", ylab = "", main = "yout")
```

# Session info

```{r}
sessionInfo()
```

