---
title: 'Sensitivity Analysis for PBPK Model'
summary: Applying the Morris screening to exam the parameter sensitivity in physiological-based pharmacokinetic model
author: Nan-Hung Hsieh
authors:
- admin
date: "2018-05-20"
output:
  blogdown::html_page:
    toc: true
    toc_depth: 2
projects: [FDA-PBPK]
categories: [sensitivity]
tags: [sensitivity, ODE, R, PBPK, deSolve]

# Featured image
# To use, add an image named `featured.jpg/png` to your page's folder.
# Placement options: 1 = Full column width, 2 = Out-set, 3 = Screen-width
# Focal point options: Smart, Center, TopLeft, Top, TopRight, Left, Right, BottomLeft, Bottom, BottomRight  
# image:
#  placement: 2
#  preview_only: true
#  focal_point: 'TopRight'
#  caption: 'Image credit: [**Unsplash**](https://unsplash.com/photos/CpkOjOcXdUY)'

---


<div id="TOC">
<ul>
<li><a href="#intro">Intro</a></li>
<li><a href="#pbpk-modeling">PBPK modeling</a><ul>
<li><a href="#define-the-model-parameters">Define the model parameters</a></li>
<li><a href="#define-the-exposure-function.">Define the exposure function.</a></li>
<li><a href="#define-the-pbpk-model">Define the PBPK model</a></li>
</ul></li>
<li><a href="#sensitivity-analysis">Sensitivity analysis</a><ul>
<li><a href="#define-the-testing-parameters">Define the testing parameters</a></li>
<li><a href="#parameter-uncertainty">Parameter uncertainty</a></li>
<li><a href="#number-of-repetitions-and-parameter-sensitivity">Number of repetitions and parameter sensitivity</a></li>
<li><a href="#mean-oat-sensitivities-and-standard-deviation">Mean OAT sensitivities and standard deviation</a></li>
<li><a href="#parameter-variation-and-model-output">Parameter variation and model output</a></li>
</ul></li>
<li><a href="#session-info">Session info</a></li>
</ul>
</div>

<p>{{% alert note %}}
<strong><strong>The post was updated on 2019-12-31 under Windows 10 x64.</strong></strong>
{{% /alert %}}</p>
<div id="intro" class="section level2">
<h2>Intro</h2>
<p>In my previous post, I used python <a href="https://nanhung.rbind.io/post/2017-08-29-salib/"><strong>SALib</strong></a> to conduct the Sobol sensitivity analysis for the simple example (Ishigami function). Now, I want to take the more complicated case to understand how to apply sensitivity analysis in a dynamic model.</p>
<p>There is an excellent example of the dynamic model, the physiological-based pharmacokinetic (PBPK) model provided from the book <a href="https://www.springer.com/la/book/9781493936076"><em>In silico Methods for Predicting Drug Toxicity</em></a> (chapter 3). This model was used to simulate the time-course of the concentration for the 1, 3-Butadiene in human body fluids and organs. The authors also provided the R source code to conduct the reproducible PBPK modeling.</p>
<p>It is an opportunity to apply the sensitivity analysis for this model. Therefore, I choose the elementary effect-based Morris screening method (<a href="https://www.tandfonline.com/doi/abs/10.1080/00401706.1991.10484804"><strong>Morris, 1991</strong></a>), which is also the advance local sensitivity analysis that change one-factor-at-a-time (OAT) to investigate the parameter impact on the model output.</p>
<p>The Morris method is an extension of the traditional OAT process that provide global converge over multiple points in the multi-dimensional parameter spaces. For each parameter, the Morris approach can calculate the mean OAT sensitivities <span class="math inline">\(\mu\)</span> and its standard deviation <span class="math inline">\(\sigma\)</span>, which represent the overall influence and the interacts/non-linear effects on the model output, respectively.</p>
<p>An improved elementary effect method was developed by <a href="https://dl.acm.org/citation.cfm?id=1238207"><strong>Campolongo et al. (2007)</strong></a>. They improved both the reliability of the sensitivity measures (adding the mean absolute value of the OAT sensitives, denoted <span class="math inline">\(\mu^*\)</span>) as well as the efficiency of the sampling strategy (generating a large number of proposed sampling trajectories and selecting a subset with the highest diversion across parameter space).</p>
<p>Compare with variance-based sensitivity analysis, the Morris method has high computing stable (lower computational cost) and only need a few sample number (lower computational resource) to reach the convergence. However, there are some disadvantages of the local method, e.g., the percentage of the output variations cannot be quantified.</p>
<p>Due to this PBPK case study is running in the pure R with the <strong>deSolve</strong> package, it might take a longer time to solve the ODEs. To have better computational performance, the Morris method is the best candidate.</p>
</div>
<div id="pbpk-modeling" class="section level1">
<h1>PBPK modeling</h1>
<p>First, we need to define and initialize the state variables. The used PBPK model was constructed from three tissue compartments (fat, well-perfused, and poorly-perfused tissues).</p>
<pre class="r"><code>y &lt;- c(&quot;Q_fat&quot; = 0,  # Quantity of butadiene in fat (mg)
       &quot;Q_wp&quot; = 0,   # ~ in well-perfused (mg)
       &quot;Q_pp&quot; = 0,   # ~ in poorly-perfused (mg)
       &quot;Q_met&quot; = 0)  # ~ metabolized (mg)</code></pre>
<div id="define-the-model-parameters" class="section level2">
<h2>Define the model parameters</h2>
<p>In this PBPK model, the unit of volumes is liter, the unit of time is minute, and the unit of flows is liter per minute.</p>
<pre class="r"><code>parameters &lt;- c(&quot;BDM&quot; = 73,    # Body mass (kg)
               &quot;Height&quot; = 1.6, # Body height (m)
               &quot;Age&quot; = 40,     # in years
               &quot;Sex&quot; = 1,      # code 1 is male, 2 is female
               &quot;Flow_pul&quot; = 5, # Pulmonary ventilation rate (L/min)
               &quot;Pct_Deadspace&quot; = 0.7, # Fraction of pulmonary deadspace
               &quot;Vent_Perf&quot; = 1.14,    # Ventilation over perfusion ratio
               &quot;Pct_LBDM_wp&quot; = 0.2,   # wp tissue as fraction of lean mass
               &quot;Pct_Flow_fat&quot; = 0.1,  # Fraction of cardiac output to fat
               &quot;Pct_Flow_pp&quot; = 0.35,  # ~ to pp
               &quot;PC_art&quot; = 2,          # Blood/air partition coefficient
               &quot;PC_fat&quot; = 22,         # Fat/blood ~
               &quot;PC_wp&quot; = 0.8,         # wp/blood ~
               &quot;PC_pp&quot; = 0.8,         # pp/blood ~
               &quot;Kmetwp&quot; = 0.25)       # Rate constant for metabolism</code></pre>
</div>
<div id="define-the-exposure-function." class="section level2">
<h2>Define the exposure function.</h2>
<p>The exposure is set to the periodic exposure (8-hour exposure per day) in a week.</p>
<pre class="r"><code>min_per_week &lt;- 60 * 24 * 7 

x1 &lt;- seq(1, min_per_week, 1440) # start exposure
x2 &lt;- seq(480, min_per_week, 1440) # stop exposure
duration &lt;- as.vector(matrix(c(x1, x2), nrow = 2, byrow = TRUE))
exposure &lt;- rep(c(10,0.1),length(duration)/2)
C_inh &lt;- approxfun(x = duration, y = exposure, method=&quot;constant&quot;, f=0, rule=2)

# Check the input concentration profile just defined
plot(C_inh(1:min_per_week), xlab = &quot;Time (min)&quot;,
     ylab = &quot;Butadiene air concentration (ppm)&quot;, type = &quot;l&quot;)</code></pre>
<p><img src="/post/2018-05-20-sensitivity-analysis-for-pbpk-model/index_files/figure-html/unnamed-chunk-3-1.png" width="672" /></p>
</div>
<div id="define-the-pbpk-model" class="section level2">
<h2>Define the PBPK model</h2>
<pre class="r"><code># Define the model equations
bd.model = function(t, y, parameters) {
  with (as.list(y), {
    with (as.list(parameters), {
      
      # Define the fixed parameters
      Height = 1.6
      Age = 40
      Sex = 1
      
      # Define some useful constants
      MW_bu = 54.0914 # butadiene molecular weight (in grams)
      ppm_per_mM = 24450 # ppm to mM under normal conditions
      # Conversions from/to ppm
      ppm_per_mg_per_l = ppm_per_mM / MW_bu
      mg_per_l_per_ppm = 1 / ppm_per_mg_per_l
      # Calculate Flow_alv from total pulmonary flow
      Flow_alv = Flow_pul * (1 - Pct_Deadspace)
      # Calculate total blood flow from Flow_alv and the V/P ratio
      Flow_tot = Flow_alv / Vent_Perf
      # Calculate fraction of body fat
      Pct_BDM_fat = (1.2 * BDM / (Height * Height) - 10.8
                     *(2 - Sex) +
                       0.23 * Age - 5.4) * 0.01
      # Actual volumes, 10% of body mass (bones…) get no butadiene
      Eff_V_fat = Pct_BDM_fat * BDM
      Eff_V_wp = Pct_LBDM_wp * BDM * (1 - Pct_BDM_fat)
      Eff_V_pp = 0.9 * BDM - Eff_V_fat - Eff_V_wp
      # Calculate actual blood flows from total flow and percent flows
      Flow_fat = Pct_Flow_fat * Flow_tot
      Flow_pp = Pct_Flow_pp * Flow_tot
      Flow_wp = Flow_tot * (1 - Pct_Flow_pp - Pct_Flow_fat)
      # Calculate the concentrations
      C_fat = Q_fat / Eff_V_fat
      C_wp = Q_wp / Eff_V_wp
      C_pp = Q_pp / Eff_V_pp
      # Venous blood concentrations at the organ exit
      Cout_fat = C_fat / PC_fat
      Cout_wp = C_wp / PC_wp
      Cout_pp = C_pp / PC_pp
      # Sum of Flow * Concentration for all compartments
      dQ_ven = Flow_fat * Cout_fat + Flow_wp * Cout_wp + Flow_pp * Cout_pp
      C_inh.current = C_inh(t) # to avoid calling C_inh() twice
      # Arterial blood concentration
      # Convert input given in ppm to mg/l to match other units
      C_art = (Flow_alv * C_inh.current * mg_per_l_per_ppm + dQ_ven) / (Flow_tot + Flow_alv / PC_art)
      # Venous blood concentration (mg/L)
      C_ven = dQ_ven / Flow_tot
      # Alveolar air concentration (mg/L)
      C_alv = C_art / PC_art
      # Exhaled air concentration (ppm!)
      if (C_alv &lt;= 0) {
        C_exh = 10E-30 # avoid round off errors
      } else {
        C_exh = (1 - Pct_Deadspace) * C_alv * ppm_per_mg_per_l +
          Pct_Deadspace * C_inh.current
      }
      # Quantity metabolized in liver (included in well-perfused)
      dQmet_wp = Kmetwp * Q_wp
      # Differentials for quantities
      dQ_fat = Flow_fat * (C_art - Cout_fat)
      dQ_wp = Flow_wp * (C_art - Cout_wp) - dQmet_wp
      dQ_pp = Flow_pp * (C_art - Cout_pp)
      dQ_met = dQmet_wp
      # The function bd.model must return at least the derivatives
      list(c(dQ_fat, dQ_wp, dQ_pp, dQ_met), # derivatives
           c(&quot;C_ven&quot; = C_ven, &quot;C_art&quot; = C_art)) # extra outputs
    }) # end with parameters
  }) # end with y
} # end bd.model</code></pre>
<p>Define the computation output times and call the ODE solver.</p>
<pre class="r"><code>library(deSolve)
times &lt;- seq(from = 0, to = min_per_week, by = 10) # A week
results &lt;- ode(times = times, func = bd.model, y = y, parms = parameters)</code></pre>
<p>Plot the model simulation results.</p>
<pre class="r"><code>plot(results, col=&quot;red&quot;)</code></pre>
<p><img src="/post/2018-05-20-sensitivity-analysis-for-pbpk-model/index_files/figure-html/unnamed-chunk-6-1.png" width="672" /></p>
</div>
</div>
<div id="sensitivity-analysis" class="section level1">
<h1>Sensitivity analysis</h1>
<p>Firstly, we use the Morris method which was provided from <strong>sensitivity</strong> package.</p>
<pre class="r"><code>library(sensitivity)</code></pre>
<pre><code>## Registered S3 method overwritten by &#39;sensitivity&#39;:
##   method    from 
##   print.src dplyr</code></pre>
<div id="define-the-testing-parameters" class="section level2">
<h2>Define the testing parameters</h2>
<p>Twelve parameters are used in this test.</p>
<pre class="r"><code>factors &lt;- c(&quot;BDM&quot;, &quot;Flow_pul&quot;, &quot;Pct_Deadspace&quot;, &quot;Vent_Perf&quot;, 
             &quot;Pct_LBDM_wp&quot;, &quot;Pct_Flow_fat&quot;, &quot;Pct_Flow_pp&quot;, 
             &quot;PC_art&quot;, &quot;PC_fat&quot;, &quot;PC_wp&quot;, &quot;PC_pp&quot;,
             &quot;Kmetwp&quot;)</code></pre>
</div>
<div id="parameter-uncertainty" class="section level2">
<h2>Parameter uncertainty</h2>
<p>Then, we need to set up the uncertainty for each parameter. Here we set the 10% variation in the testing parameters.</p>
<pre class="r"><code>LL &lt;- 0.9 # 10% lower limit
UL &lt;- 1.1 # 10% upper limit

# Define the lower and upper limits that will be the input to the morris function
binf &lt;- c(parameters[&quot;BDM&quot;]*LL, 
          parameters[&quot;Flow_pul&quot;]*LL,
          parameters[&quot;Pct_Deadspace&quot;]*LL,
          parameters[&quot;Vent_Perf&quot;]*LL,
          parameters[&quot;Pct_LBDM_wp&quot;]*LL,
          parameters[&quot;Pct_Flow_fat&quot;]*LL,
          parameters[&quot;Pct_Flow_pp&quot;]*LL,
          parameters[&quot;PC_art&quot;]*LL,
          parameters[&quot;PC_fat&quot;]*LL,
          parameters[&quot;PC_wp&quot;]*LL,
          parameters[&quot;PC_pp&quot;]*LL,
          parameters[&quot;Kmetwp&quot;]*LL)
bsup &lt;- c(parameters[&quot;BDM&quot;]*UL, 
          parameters[&quot;Flow_pul&quot;]*UL,
          parameters[&quot;Pct_Deadspace&quot;]*UL,
          parameters[&quot;Vent_Perf&quot;]*UL,
          parameters[&quot;Pct_LBDM_wp&quot;]*UL,
          parameters[&quot;Pct_Flow_fat&quot;]*UL,
          parameters[&quot;Pct_Flow_pp&quot;]*UL,
          parameters[&quot;PC_art&quot;]*UL,
          parameters[&quot;PC_fat&quot;]*UL,
          parameters[&quot;PC_wp&quot;]*UL,
          parameters[&quot;PC_pp&quot;]*UL,
          parameters[&quot;Kmetwp&quot;]*UL)</code></pre>
<p>To check the convergence of the sensitivity index, we can set up the sequence of the sampling number. After that, we can apply the for-loop to do the morris sensitivity analysis and link with numerical analysis from <code>deSolve::ode</code> function. In this case, I examine the parameter sensitivity under the exposure time at 8-hour (stop point of the first exposure) and investigate the parameter sensitivity. Also, we only focused on the parameter effect on venous blood concentration.</p>
<pre class="r"><code>sample &lt;- seq(from = 20, to = 140, by = 20)

for (i in 1:length(sample)) {
  set.seed(12345)
  x &lt;- morris(model = NULL, factors = factors, r = sample[i],
              design = list(type = &quot;oat&quot;, levels = 6, grid.jump = 3), 
              binf = binf, bsup = bsup, scale = TRUE)
  
  for (iteration in 1:nrow(x$X)) { 
    
    parameters[&quot;BDM&quot;] = x$X[iteration,&quot;BDM&quot;]
    parameters[&quot;Flow_pul&quot;] = x$X[iteration,&quot;Flow_pul&quot;]
    parameters[&quot;Pct_Deadspace&quot;] = x$X[iteration,&quot;Pct_Deadspace&quot;]
    parameters[&quot;Vent_Perf&quot;] = x$X[iteration,&quot;Vent_Perf&quot;]
    parameters[&quot;Pct_LBDM_wp&quot;] = x$X[iteration,&quot;Pct_LBDM_wp&quot;]
    parameters[&quot;Pct_Flow_fat&quot;] = x$X[iteration,&quot;Pct_Flow_fat&quot;]
    parameters[&quot;Pct_Flow_pp&quot;] = x$X[iteration,&quot;Pct_Flow_pp&quot;]
    parameters[&quot;PC_art&quot;] = x$X[iteration,&quot;PC_art&quot;]
    parameters[&quot;PC_fat&quot;] = x$X[iteration,&quot;PC_fat&quot;]
    parameters[&quot;PC_wp&quot;] = x$X[iteration,&quot;PC_wp&quot;]
    parameters[&quot;PC_pp&quot;] = x$X[iteration,&quot;PC_pp&quot;]
    parameters[&quot;Kmetwp&quot;] = x$X[iteration,&quot;Kmetwp&quot;]
    
    # We focus on time at 8 hour (stop exposure),
    times = c(0, 480)
    # Integrate
    tmp = ode(times = times, func = bd.model, y = y, parms = parameters)
    if (iteration == 1) { # initialize
      results = tmp[2,-1]
      sampled.parms = c(parameters[&quot;BDM&quot;], 
                        parameters[&quot;Flow_pul&quot;],
                        parameters[&quot;Pct_Deadspace&quot;],
                        parameters[&quot;Vent_Perf&quot;],
                        parameters[&quot;Pct_LBDM_wp&quot;],
                        parameters[&quot;Pct_Flow_fat&quot;],
                        parameters[&quot;Pct_Flow_pp&quot;],
                        parameters[&quot;PC_art&quot;],
                        parameters[&quot;PC_fat&quot;],
                        parameters[&quot;PC_wp&quot;],
                        parameters[&quot;PC_pp&quot;],
                        parameters[&quot;Kmetwp&quot;])
    } else { # accumulate
      results = rbind(results, tmp[2,-1])
      sampled.parms = rbind(sampled.parms,
                            c(parameters[&quot;BDM&quot;], 
                              parameters[&quot;Flow_pul&quot;],
                              parameters[&quot;Pct_Deadspace&quot;],
                              parameters[&quot;Vent_Perf&quot;],
                              parameters[&quot;Pct_LBDM_wp&quot;],
                              parameters[&quot;Pct_Flow_fat&quot;],
                              parameters[&quot;Pct_Flow_pp&quot;],
                              parameters[&quot;PC_art&quot;],
                              parameters[&quot;PC_fat&quot;],
                              parameters[&quot;PC_wp&quot;],
                              parameters[&quot;PC_pp&quot;],
                              parameters[&quot;Kmetwp&quot;]))
    }
  }
  
  # 
  tell(x, results[,&quot;C_ven&quot;]) # We focus on parameter effect on venous blood concentration
  
  if (i == 1){
    X &lt;- apply(abs(x$ee), 2, mean)  
  } else {
    X &lt;- rbind(X, apply(abs(x$ee), 2, mean))
  }
}</code></pre>
</div>
<div id="number-of-repetitions-and-parameter-sensitivity" class="section level2">
<h2>Number of repetitions and parameter sensitivity</h2>
<p>Through this plot, we can examine the variation and converge of the parameter. It seems that each sensitivity index of the parameter was stable across all sampling number. Also, we can find the fraction of pulmonary dead space <code>Pct_Deadspace</code> is the most influential parameter.</p>
<pre class="r"><code># Manipulate the output result for plotting
row.names(X) &lt;- sample
meltX &lt;- reshape::melt(X)
ee_lim &lt;- c(min(abs(x$ee)), max(abs(x$ee)))

library(viridis) # use viridis to create distinct colors </code></pre>
<pre><code>## Loading required package: viridisLite</code></pre>
<pre class="r"><code>par(mar=c(4,4,2,1))
plot(sample, subset(meltX, X2 == factors[1])[,3], type=&quot;b&quot;, col=viridis_pal()(12)[1],
     frame.plot = FALSE, 
     xlab=&quot;number of repetitions&quot;,
     ylab=expression(paste(mu,&quot;*&quot;)), ylim=ee_lim, xlim = c(20,160))
for( i in 2:12){
  lines(sample, subset(meltX, X2 == factors[i])[,3], type=&quot;b&quot;, col=viridis_pal()(12)[i])
}
text(140, subset(meltX, X1 == 140)[,3], factors, pos = 4)</code></pre>
<p><img src="/post/2018-05-20-sensitivity-analysis-for-pbpk-model/index_files/figure-html/unnamed-chunk-11-1.png" width="864" /></p>
</div>
<div id="mean-oat-sensitivities-and-standard-deviation" class="section level2">
<h2>Mean OAT sensitivities and standard deviation</h2>
<p>This visualization provides the information to examine the parameter sensitivity and the relationships between model parameters and its related output. According to the output result, we can find the relationship between the parameter values and model outputs are between linear and monotonic.</p>
<pre class="r"><code>plot(x, xlim=ee_lim, main =&quot;number of repetitions = 140&quot;)
abline(0,1) # non-linear and/or non-monotonic
abline(0,0.5, lty = 2) # monotonic
abline(0,0.1, lty = 3) # almost linear
legend(&quot;bottomright&quot;, legend = c(&quot;non-linear and/or non-monotonic&quot;,
                                 &quot;monotonic&quot;,
                                 &quot;linear&quot;), lty = c(1:3))</code></pre>
<p><img src="/post/2018-05-20-sensitivity-analysis-for-pbpk-model/index_files/figure-html/unnamed-chunk-12-1.png" width="672" /></p>
</div>
<div id="parameter-variation-and-model-output" class="section level2">
<h2>Parameter variation and model output</h2>
<p>To investigate the parameter effect on the PBPK model outputs, we used the following visualization methods for all parameters and the most influential parameter <code>Pct_Deadspace</code> and less influential parameter <code>PC_pp</code>.</p>
<p>For all parameters</p>
<pre class="r"><code>par(mfrow=c(3,4))
for (i in 1:12){
  plot(x$X[,i], x$y, main = x$factors[i], xlab = &quot;&quot;, ylab = &quot;predict conc.&quot;)
}</code></pre>
<p><img src="/post/2018-05-20-sensitivity-analysis-for-pbpk-model/index_files/figure-html/unnamed-chunk-13-1.png" width="672" /></p>
<p>For most influential parameter <code>Pct_Deadspace</code></p>
<pre class="r"><code>library(ggplot2)
library(plyr)

sensiX &lt;- data.frame(x$X[,&quot;Pct_Deadspace&quot;], x$y)
names(sensiX) &lt;- c(&quot;Pct_Deadspace&quot;, &quot;Predict.conc&quot;)
musensi &lt;- ddply(sensiX, &quot;Pct_Deadspace&quot;, summarize, mean.conc=mean(Predict.conc))

ggplot(sensiX, aes(x=Predict.conc, color=as.factor(Pct_Deadspace))) +
  geom_density() + scale_color_discrete(name=&quot;Pct_Deadspace&quot;) +
  geom_vline(data=musensi, aes(xintercept=mean.conc, color=as.factor(Pct_Deadspace)),
             linetype=&quot;dashed&quot;) +
  theme_minimal()</code></pre>
<p><img src="/post/2018-05-20-sensitivity-analysis-for-pbpk-model/index_files/figure-html/unnamed-chunk-14-1.png" width="672" /></p>
<p>For less influential parameter <code>PC_pp</code></p>
<pre class="r"><code>insensiX &lt;- data.frame(x$X[,&quot;PC_pp&quot;], x$y)
names(insensiX) &lt;- c(&quot;PC_pp&quot;, &quot;Predict.conc&quot;)
muinsensi &lt;- ddply(insensiX, &quot;PC_pp&quot;, summarize, mean.conc=mean(Predict.conc))

ggplot(insensiX, aes(x=Predict.conc, color=as.factor(PC_pp))) +
  geom_density() + scale_color_discrete(name=&quot;PC_pp&quot;) +
  geom_vline(data=muinsensi, aes(xintercept=mean.conc, color=as.factor(PC_pp)),
             linetype=&quot;dashed&quot;) +
  theme_minimal()</code></pre>
<p><img src="/post/2018-05-20-sensitivity-analysis-for-pbpk-model/index_files/figure-html/unnamed-chunk-15-1.png" width="672" /></p>
<p>Through this method, we can quickly check the parameter sensitivity in the PBPK model and compare the parameter effects on model output. However, this is just a simple test case. To do the “complete” sensitivity analysis, we still need to find the reasonable parameter uncertainty and its range (the sensitivity may change if we revise the range of parameter uncertainty). However, this step-by-step method can provide essential information for beginners to apply the sensitivity in the dynamic model. Also, the parameter sensitivity might change with time. It would be better to investigate the time-varying sensitivity index in the factor prioritization.</p>
</div>
</div>
<div id="session-info" class="section level1">
<h1>Session info</h1>
<pre class="r"><code>sessionInfo()</code></pre>
<pre><code>## R version 3.6.2 (2019-12-12)
## Platform: x86_64-w64-mingw32/x64 (64-bit)
## Running under: Windows 10 x64 (build 17763)
## 
## Matrix products: default
## 
## locale:
## [1] LC_COLLATE=English_United States.1252 
## [2] LC_CTYPE=English_United States.1252   
## [3] LC_MONETARY=English_United States.1252
## [4] LC_NUMERIC=C                          
## [5] LC_TIME=English_United States.1252    
## 
## attached base packages:
## [1] stats     graphics  grDevices utils     datasets  methods   base     
## 
## other attached packages:
## [1] plyr_1.8.5         ggplot2_3.2.1      viridis_0.5.1      viridisLite_0.3.0 
## [5] sensitivity_1.16.3 deSolve_1.25      
## 
## loaded via a namespace (and not attached):
##  [1] Rcpp_1.0.3        compiler_3.6.2    pillar_1.4.2      tools_3.6.2      
##  [5] boot_1.3-23       digest_0.6.23     evaluate_0.14     lifecycle_0.1.0  
##  [9] tibble_2.1.3      gtable_0.3.0      pkgconfig_2.0.3   rlang_0.4.2      
## [13] cli_2.0.0         rstudioapi_0.10   yaml_2.2.0        blogdown_0.17    
## [17] xfun_0.11         gridExtra_2.3     dplyr_0.8.3       withr_2.1.2      
## [21] stringr_1.4.0     knitr_1.26        tidyselect_0.2.5  grid_3.6.2       
## [25] reshape_0.8.8     glue_1.3.1        R6_2.4.1          fansi_0.4.0      
## [29] rmarkdown_2.0     bookdown_0.16     sessioninfo_1.1.1 farver_2.0.1     
## [33] purrr_0.3.3       magrittr_1.5      scales_1.1.0      htmltools_0.4.0  
## [37] assertthat_0.2.1  colorspace_1.4-1  labeling_0.3      stringi_1.4.3    
## [41] lazyeval_0.2.2    munsell_0.5.0     crayon_1.3.4</code></pre>
</div>
