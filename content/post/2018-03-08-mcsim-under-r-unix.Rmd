---
title: MCSim under R (Unix)
summary: The exercise of use GNU MCsim under R in Unix system 
author: Nan-Hung Hsieh
date: '2018-03-08'
slug: mcsim-under-r-unix
categories: []
tags:
  - mcsim
  - R
  - unix
output:
  blogdown::html_page:
    toc: true
    number_sections: true
    toc_depth: 1
---

## Prerequisites

- R
- R Studio (optional)
- MCSim 

This exercise was sourced from the file [**MCSim under R**](https://www.gnu.org/software/mcsim/mcsim_under_R.zip) in [**GNU MCSim**](https://www.gnu.org/software/mcsim/). The testing operation system is [**Lubuntu v17.10**](https://lubuntu.net/) with MCSim v5.6.6 and R v3.4.0 installed.

{{% alert warning %}}
Be sure you're in the right place. Check `.Platform$OS.type == "unix"` first! Windows user can read [**this instruction**](https://nanhung.rbind.io/post/mcsim-under-r-windows/).
{{% /alert %}}

Also, we can use this method,

```{R}
cat(system("lsb_release -a", intern = T), sep = '\n')
```

---

# Solve ODE in pure R

```{R, warning=FALSE}
library(deSolve)

model <- function(t, Y, parameters) {
  with (as.list(parameters), {
    dy1 = -k1*Y[1] + k2*Y[2]*Y[3];
    dy3 = k3*Y[2]*Y[2];
    dy2 = -dy1 - dy3;
    list(c(dy1, dy2, dy3));
    })
}

jac <- function (t, Y, parameters) {
  with (as.list(parameters), {
       PD[1,1] <- -k1;
       PD[1,2] <- k2*Y[3];
       PD[1,3] <- k2*Y[2];
       PD[2,1] <- k1;
       PD[2,3] <- -PD[1,3];
       PD[3,2] <- k3*Y[2];
       PD[2,2] <- -PD[1,2] - PD[3,2];

       return(PD) 
    }) 
}


parms <- c(k1 = 0.04, k2 = 1e4, k3=3e7) 

Y <- c(y1 = 1.0, y2 = 0.0, y3 = 0.0)

times  <- c(0, 0.4*10^(0:11))

PD <- matrix(nrow = 3, ncol = 3, data = 0)

out.1 <- ode(Y, times, model, parms = parms, jacfunc = jac)

plot(out.1,type="b",log="x")

```

# Compile the MCSim model file and solve by deSolve

## Prepare model file

The testing model `simple.model` file looks like this:

```
#------------------------------------------------------------------------------
# the deSolve example model (simple.model)
#------------------------------------------------------------------------------

States = {y0, y1, y2};

Outputs = {yout};

# Parameters
k1 = 1;
k2 = 1;
k3 = 1;

Dynamics {

  dt(y0) = -k1 * y0 + k2 * y1 * y2; 
  dt(y2) =  k3 * y1 * y1; 
  dt(y1) = -dt(y0) - dt(y2);

  yout = y0 + y1 + y2;

} # End of Dynamics

Events {
  y0 = 1;
}

Roots { # here we need inlining, otherwise 'gout' will not be understood 
  Inline ( gout[0] = y[0] - 0.5; );
}

End.
```
The following step can compile the `simple.model` file and create the executable program 

{{% alert warning %}}
Make sure that the `simple.model` is put in the working directory!
{{% /alert %}}

```{R, warning=FALSE}

mName <- "simple.model"

# Create .c file and use -R to generate "simple.model_inits.R" initialization file
system (paste("mod -R ", mName, " ", mName, ".c", sep = "")) 
system (paste("R CMD SHLIB ", mName, ".c", sep = "")) # create .o and .so files
dyn.load(paste(mName, .Platform$dynlib.ext, sep=""))
source ("simple.model_inits.R")

parms_init <- initParms () # define parameter values
Y_init <- initStates (parms) # define initial state values

# Check the default parameters, initial values
parms; Y

# list output variable, not a nice name will will call it "Sum" below
Outputs 

# set output times, time 0 must be given
times <- c(0, 0.4*10^(0:11)) # This setting is same as section 1

out.2.1 <- ode(Y_init, times, func = "derivs", parms = parms_init, 
               jacfunc = "jac", dllname = "simple.model", 
               initfunc = "initmod", nout = 1, outnames = "Sum")

plot(out.2.1, log="x",type="b")
```

{{% alert note %}}
We can't find any change in the dynamic process. It is due to the all initial value equal to 0.  
{{% /alert %}}

## Customize the parameter and initial values

```{R, warning=FALSE}

# Use the samee parameters and initial values in section 1
out.2.2 <- ode(Y, times, func = "derivs", parms = parms,
               dllname = mName, initfunc = "initmod",
               nout = 1, outnames = "Sum")

# Here is the output data frame
head(out.2.2)

# Plotting
plot(out.2.2, log="x",type="b")

# Use "which" to select specific variables
plot(out.2.2, log="x",type="b", which = c("y1", "y2", "y3"))

```

# Compile the MCSim model file and solve by MCSim

## Prepare in file

In this part, we need to put `simple.in` file in the working directory. The in file define the initial and parameter values, respectively. Also,we need to set the output time steps and intervals. The source code looks like this:

```
#------------------------------------------------------------------------------
# the deSolve example model run with GNU MCSim (simple.in)
#------------------------------------------------------------------------------

Integrate (Lsodes, 1E-7, 1E-7, 1);

Simulation {

  y0 = 1;

  # Parameters
  k1 = 0.04;
  k2 = 1e4;
  k3 = 3e7;

  Print (y0, 0, 4e-1, 4e+0, 4e+1, 4e+2, 4e+3, 4e+4, 4e+5, 4e+6, 4e+7, 4e+8, 
         4e+9, 4e+10);
  Print (y1, 0, 4e-1, 4e+0, 4e+1, 4e+2, 4e+3, 4e+4, 4e+5, 4e+6, 4e+7, 4e+8, 
         4e+9, 4e+10);
  Print (y2, 0, 4e-1, 4e+0, 4e+1, 4e+2, 4e+3, 4e+4, 4e+5, 4e+6, 4e+7, 4e+8, 
         4e+9, 4e+10);

  Print (yout, 0, 4e-1, 4e+0, 4e+1, 4e+2, 4e+3, 4e+4, 4e+5, 4e+6, 4e+7, 4e+8, 
         4e+9, 4e+10);

}

End.
```
The following step compile the `simple.model` file and create the executable program named `mcsim.simple`

```{R, warning=FALSE}

Name <- "simple"
mName <- "simple.model"

# compile the "simple.model" to "mcsim.simple"
system(paste("makemcsim ", mName, sep = ""))

# run the simulation input file
# put its name here
inName <- "simple.in"

# run!
system(paste("./mcsim.", Name, " ", inName, sep = ""))

# the output file is called out by default, load it
out.3 <- read.delim("sim.out", skip = 2)

head (out.3)

# look

lo = layout(t(matrix(1:4, ncol = 2)), respect = TRUE)
plot(out.3[,1], out.3[,2], log="x",type="b", xlab = "time", ylab = "", main = "y1")
plot(out.3[,1], out.3[,3], log="x",type="b", xlab = "time", ylab = "", main = "y2")
plot(out.3[,1], out.3[,4], log="x",type="b", xlab = "time", ylab = "", main = "y3")

```
