---
title: MCSim under R (Unix)
summary: The exercise of use GNU MCsim under R in Unix system 
author: Nan-Hung Hsieh
date: '2018-03-08'
slug: mcsim-under-r-unix
categories: []
tags:
  - mcsim
  - R
  - unix
output:
  blogdown::html_page:
    toc: true
    number_sections: true
    toc_depth: 1
---

This exercises were sourced from the file [**MCSim under R**](https://www.gnu.org/software/mcsim/mcsim_under_R.zip) in [**GNU MCSim**](https://www.gnu.org/software/mcsim/). The testing operation system is Lubuntu 17.10.

{{% alert warning %}}
Be sure you're in the right place. Use `.Platform$OS.type == "unix"` first!
{{% /alert %}}

---

# Run ODE in pure R

```{R, warning=FALSE}
library(deSolve)

model <- function(t, Y, parameters) {
  with (as.list(parameters), {
    dy1 = -k1*Y[1] + k2*Y[2]*Y[3];
    dy3 = k3*Y[2]*Y[2];
    dy2 = -dy1 - dy3;
    list(c(dy1, dy2, dy3));
    })
}

jac <- function (t, Y, parameters) {
  with (as.list(parameters), {
       PD[1,1] <- -k1;
       PD[1,2] <- k2*Y[3];
       PD[1,3] <- k2*Y[2];
       PD[2,1] <- k1;
       PD[2,3] <- -PD[1,3];
       PD[3,2] <- k3*Y[2];
       PD[2,2] <- -PD[1,2] - PD[3,2];

       return(PD) 
    }) 
}


parms <- c(k1 = 0.04, k2 = 1e4, k3=3e7) 

Y <- c(1.0, 0.0, 0.0)

times  <- c(0, 0.4*10^(0:11))

PD <- matrix(nrow = 3, ncol = 3, data = 0)

out <- ode(Y, times, model, parms = parms, jacfunc = jac)

plot(out,type="b",log="x")

```

# Compile the MCSim model file and solve by deSolve

## Prepare model file

The testing model `simple.model` file looks like this:

```
#------------------------------------------------------------------------------
# the deSolve example model
#------------------------------------------------------------------------------

States = {y0, y1, y2};

Outputs = {yout};

# Parameters
k1 = 1;
k2 = 1;
k3 = 1;

Dynamics {

  dt(y0) = -k1 * y0 + k2 * y1 * y2; 
  dt(y2) =  k3 * y1 * y1; 
  dt(y1) = -dt(y0) - dt(y2);

  yout = y0 + y1 + y2;

} # End of Dynamics

Events {
  y0 = 1;
}

Roots { # here we need inlining, otherwise 'gout' will not be understood 
  Inline ( gout[0] = y[0] - 0.5; );
}

End.
```
The following step can compile the `simple.model` file and create the executable program 

{{% alert warning %}}
Make sure that the `simple.model` is put in the working directory!
{{% /alert %}}

```{R, warning=FALSE}

mName <- "simple.model"

# Create .c file and use -R to generate "simple.model_inits.R" initialization file
system (paste("mod -R ", mName, " ", mName, ".c", sep = "")) 
system (paste("R CMD SHLIB ", mName, ".c", sep = "")) # create .o and .so files
dyn.load(paste(mName, .Platform$dynlib.ext, sep=""))
source ("simple.model_inits.R")

parms <- initParms () # define parameter values
Y <- initStates (parms) # define initial state values

# Check the default parameters, initial values
parms; Y

# list output variable, not a nice name will will call it "Sum" below
Outputs 

# set output times, time 0 must be given
times <- c(0, 0.4*10^(0:11))

out.1.1 <- ode(Y, times, func = "derivs", parms = parms, jacfunc = "jac", dllname = "simple.model", initfunc = "initmod", nout = 1, outnames = "Sum")

plot(out.1.1, log="x",type="b")
```

{{% alert note %}}
We can't find any change in the dynamic process. It is due to the all default variables equal to 0. 
{{% /alert %}}

## Customize the parameter and initial values

```{R, warning=FALSE}

# set parameter values
parms <- c(k1 = 0.04, k2 = 1e4, k3=3e7)

# set initial values
Y <- c(y1 = 1.0, y2 = 0.0, y3 = 0.0)

out.1.2 <- ode(Y, times, func = "derivs", parms = parms,
               dllname = mName, initfunc = "initmod",
               nout = 1, outnames = "Sum")

# Here is the output data frame
head(out.1.2)

# Plotting
plot(out.1.2, log="x",type="b")

# Use "which" to select specific variables
plot(out.1.2, log="x",type="b", which = c("y1", "y2", "y3"))

```