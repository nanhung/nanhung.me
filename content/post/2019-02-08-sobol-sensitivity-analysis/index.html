---
title: 'Sobol Sensitivity Analysis for Pharmacokinetic Model'
summary: Using mrgsolve package and its approach to conduct Sobol sensitivity analysis in pharmacokinetic modeling
authors:
- admin
date: "2019-02-08"
output:
  blogdown::html_page:
    toc: true
    toc_depth: 2
projects: [PBPK]
categories: [sensitivity]
tags: [sensitivity, pharmacokinetics, Sobol, mrgsolve]

# Featured image
# To use, add an image named `featured.jpg/png` to your page's folder.
# Placement options: 1 = Full column width, 2 = Out-set, 3 = Screen-width
# Focal point options: Smart, Center, TopLeft, Top, TopRight, Left, Right, BottomLeft, Bottom, BottomRight  
# image:
#  placement: 2
#  preview_only: true
#  focal_point: 'TopRight'
#  caption: 'Image credit: [**Unsplash**](https://unsplash.com/photos/CpkOjOcXdUY)'

---


<div id="TOC">
<ul>
<li><a href="#prerequisites">Prerequisites</a></li>
<li><a href="#reproducible-analysis">Reproducible analysis</a><ul>
<li><a href="#the-sunitinib-pk-model">The sunitinib PK model</a></li>
<li><a href="#sunitinib-dosing">Sunitinib dosing</a></li>
<li><a href="#a-bunch-of-helper-functions">A bunch of helper functions</a></li>
<li><a href="#sobol-sensitivity-analysis">Sobol sensitivity analysis</a></li>
<li><a href="#results">Results</a></li>
</ul></li>
<li><a href="#methods-and-defined-functions">Methods and defined functions</a><ul>
<li><a href="#log-uniform-quasi-monte-carlo-sampling">Log-uniform &amp; quasi-Monte Carlo sampling</a></li>
<li><a href="#convergence-analysis">Convergence analysis</a></li>
</ul></li>
<li><a href="#results-1">Results</a><ul>
<li><a href="#sobol-sensitivity-analysis-1">Sobol sensitivity analysis</a></li>
<li><a href="#convergence-assessment">Convergence assessment</a></li>
</ul></li>
<li><a href="#take-away">Take away</a></li>
<li><a href="#session-info">Session info</a></li>
</ul>
</div>

<p>{{% alert note %}}
<strong><strong>The post was updated on 2020-01-01 under Windows 10 x64.</strong></strong>
{{% /alert %}}</p>
<p>I find a great <a href="https://github.com/mrgsolve/gallery/blob/master/application/sobol.md">example</a> of performing Sobol sensitivity analysis within pharmacokinetic modeling through <a href="https://mrgsolve.github.io/">mrgsolve</a> and <a href="https://dpastoor.github.io/PKPDmisc/">PKPDmisc</a>. I didn’t have any experience to use these packages in my study. But this is a good opportunity to understand how they work since I have prior knowledge in the sensitivity analysis. Last year, I was lucky to have a chance to participate in <a href="https://ec.europa.eu/jrc/en/event/training-course/samo-2018">the 10th summer school on Sensitivity Analysis of Model Output</a> (SAMO 2018).<br />
Here I want to apply some techniques that I learned in this SAMO summer school, and it might be helpful to apply Sobol sensitivity analysis in pharmacokinetic modeling. Maybe in the future, I can integrate this approach in <a href="https://nanhung.rbind.io/pksensi/index.html">pksensi</a>.</p>
<div id="prerequisites" class="section level2">
<h2>Prerequisites</h2>
<p>The list of R packages should be installed first to do the following testing. The related functions are also listed behind the package.</p>
<pre class="r"><code>library(tidyverse) 
library(mrgsolve) # mrgsim_ei
library(PKPDmisc) # auc_partial 
library(sensitivity) # sobol2007
library(randtoolbox) # sobol
library(reshape2) # melt
library(LSD) # heatscatter</code></pre>
<p>For Windows OS, some build tools need to pre-install, such as Rtools. Also, be sure to assign the right PATH to Rtools.</p>
<pre class="r"><code>Sys.setenv(PATH = paste(&quot;c:\\Rtools\\bin&quot;, Sys.getenv(&quot;PATH&quot;), sep=&quot;;&quot;))
Sys.setenv(PATH = paste(&quot;c:\\Rtools\\mingw_64\\bin&quot;, Sys.getenv(&quot;PATH&quot;), sep=&quot;;&quot;))</code></pre>
<pre class="r"><code>pkgbuild::check_build_tools(debug=TRUE)</code></pre>
<pre><code>## Scanning R CMD config CC...
## cc_path: c:/Rtools/mingw_64/bin/gcc 
## install_path: c:/Rtools 
## Found compatible gcc from R CMD config CC</code></pre>
<pre><code>## Your system is ready to build packages!</code></pre>
<hr />
</div>
<div id="reproducible-analysis" class="section level1">
<h1>Reproducible analysis</h1>
<p>This section is used to reproduce the result in previous post.</p>
<div id="the-sunitinib-pk-model" class="section level2">
<h2>The sunitinib PK model</h2>
<pre class="r"><code>mod &lt;- mread(&quot;sunit&quot;, &quot;models&quot;) %&gt;% 
  update(end = 24, delta = 1) %&gt;% zero_re</code></pre>
<pre><code>## Building sunit ... done.</code></pre>
<pre class="r"><code>see(mod)</code></pre>
<pre><code>## 
## Model file:  sunit.cpp 
## $PARAM
## TVCL = 51.8
## TVVC = 2030
## TVKA = 0.195
## TVQ = 7.22
## TVVP = 583
## WTVC = 0.459
## SEXCL = -0.0876
## ASIANCL = -0.130
## GISTCL = -0.285
## SOLIDCL = -0.269
## MRCCCL = -0.258
## SEX = 0, ASIAN = 0, GIST = 0
## SOLID = 0, MRCC = 0, WT = 76.9
## 
## $MAIN
##   double CL  = TVCL * (1+SEXCL*SEX) * (1+ASIANCL*ASIAN) * 
##   (1+GISTCL*GIST) * (1+SOLIDCL*SOLID) * (1+MRCCCL*MRCC) * exp(ETA(1));
## 
## double V2 = TVVC*pow(WT/76.9, WTVC)*exp(ETA(2));
## double KA = TVKA*exp(ETA(3));
## double Q  = TVQ;
## double V3 = TVVP;
## 
## $OMEGA 0.14 0.18 0.64
## 
## $SIGMA 0.146
## 
## $PKMODEL cmt = &quot;GUT CENT, PERIPH&quot;, depot = TRUE
## 
## $POST
## capture CP = (1000*CENT/V2);</code></pre>
</div>
<div id="sunitinib-dosing" class="section level2">
<h2>Sunitinib dosing</h2>
<pre class="r"><code>sunev &lt;- function(amt = 50,...) ev(amt = amt, ...)</code></pre>
</div>
<div id="a-bunch-of-helper-functions" class="section level2">
<h2>A bunch of helper functions</h2>
<pre class="r"><code>gen_samples&lt;- function(n, l, which = names(l), factor = c(0.01,100)) {
  vars &lt;- select_vars(names(l), !!(enquo(which)))
  l &lt;- as.list(l)[vars]
  l &lt;- lapply(l, function(x) {
    x*factor  
  })
  n &lt;- length(l)*n*2
  df &lt;- as.data.frame(l)
  len &lt;- length(df)
  X &lt;- matrix(ncol=len, nrow=n)
  colnames(X) &lt;- names(df)
  Y &lt;- X
  for(i in seq(len)){
    r &lt;- runif(n, df[1,i], df[2,i])
    X[,i] &lt;- r
    r &lt;- runif(n, df[1,i], df[2,i])
    Y[,i] &lt;- r
  }
  return(list(x1 = as.data.frame(X), x2 = as.data.frame(Y)))
} </code></pre>
<pre class="r"><code>sim_chunk &lt;- function(mod, x) {
  mrgsim_ei(x = mod, ev = sunev(), 
            idata = x, obsonly = TRUE) %&gt;% 
    as_data_frame
}</code></pre>
<pre class="r"><code>batch_run &lt;- function(x) {
  out &lt;- sim_chunk(mod,x)
  out &lt;- group_by(out,ID) %&gt;% 
    summarise(AUC = auc_partial(time,CP))
  return(out$AUC)
}</code></pre>
</div>
<div id="sobol-sensitivity-analysis" class="section level2">
<h2>Sobol sensitivity analysis</h2>
<p>The sampling method is based on this <a href="https://github.com/metrumresearchgroup/pbpk-qsp-mrgsolve/blob/master/docs/global_sensitivity_analysis.md">example</a>. Therefore I can fully reproduce the same output.</p>
<pre class="r"><code>set.seed(88771)
samp &lt;- gen_samples(6000, param(mod), TVCL:TVVP)</code></pre>
<pre><code>## Warning: select_vars() is deprecated. 
## Please use tidyselect::vars_select() instead
## This warning is displayed once per session.</code></pre>
<pre class="r"><code>head(samp$x1)</code></pre>
<pre><code>##       TVCL      TVVC      TVKA      TVQ      TVVP
## 1 2837.253 166875.30 11.013982 108.5520 34567.952
## 2 3490.800  14354.07 18.822180 547.8690 50545.862
## 3 2097.291 181348.34  9.694288 427.9187 24586.856
## 4 2341.387  26875.49 11.256036 698.8196  4460.470
## 5 5119.695  99479.77  2.140000 666.6529 45071.206
## 6 3456.046  19526.79  9.308946 240.5433  3260.133</code></pre>
<pre class="r"><code>x &lt;- sobol2007(batch_run, X1=samp$x1, X2=samp$x2, nboot=100)</code></pre>
<pre><code>## Warning: `as_data_frame()` is deprecated, use `as_tibble()` (but mind the new semantics).
## This warning is displayed once per session.</code></pre>
</div>
<div id="results" class="section level2">
<h2>Results</h2>
<pre class="r"><code>plot(x)</code></pre>
<p><img src="/post/2019-02-08-sobol-sensitivity-analysis/index_files/figure-html/unnamed-chunk-12-1.png" width="672" /></p>
<p>The result shows that only TVCL and TVVC can significantly dominate the output result. Also, it’s difficult to determine the influence of TVKA, TVQ, and TVVP.</p>
<pre class="r"><code>x</code></pre>
<pre><code>## 
## Call:
## sobol2007(model = batch_run, X1 = samp$x1, X2 = samp$x2, nboot = 100)
## 
## Model runs: 420000 
## 
## First order indices:
##           original          bias   std. error     min. c.i.   max. c.i.
## TVCL  0.1601012111 -3.961186e-04 0.0165887575  0.1202675221 0.191178797
## TVVC  0.3320740078 -1.285038e-04 0.0294846206  0.2733978327 0.391703368
## TVKA  0.0010487694 -6.613295e-05 0.0007313674 -0.0004292212 0.002390704
## TVQ   0.0051811252 -1.872421e-04 0.0019048728  0.0014201887 0.009856908
## TVVP -0.0004045875 -5.127682e-05 0.0009684934 -0.0026189101 0.001518605
## 
## Total indices:
##        original          bias  std. error    min. c.i.  max. c.i.
## TVCL 0.62250758 -7.167859e-04 0.018940870  0.584373307 0.65593812
## TVVC 0.81936724 -1.052853e-03 0.020453124  0.779979644 0.86583928
## TVKA 0.01614792  2.026065e-04 0.005829411  0.003003340 0.02467302
## TVQ  0.04231475  1.472590e-03 0.052447894 -0.075011615 0.11446682
## TVVP 0.02456133  1.780932e-05 0.008600429  0.002349588 0.03899559</code></pre>
</div>
</div>
<div id="methods-and-defined-functions" class="section level1">
<h1>Methods and defined functions</h1>
<div id="log-uniform-quasi-monte-carlo-sampling" class="section level2">
<h2>Log-uniform &amp; quasi-Monte Carlo sampling</h2>
<p>Based on the <code>gen_samples()</code> above, I further create two functions. The first one sample the parameters under the log-transformed parameter range. The main reason to develop this function is that the setting range of model parameters are extremely large in this example. The original example generated uniform samples from a 100 fold decrease to 100 fold increase based on the nominal parameter value. It might cause an unexpected sampling bias. Therefore, the new function aims to solve this problem.</p>
<p>Let’s call this function as <code>gen_samples_1()</code>.</p>
<pre class="r"><code>gen_samples_1 &lt;- function(n, l, which = names(l), factor = c(0.01,100)) {
  vars &lt;- select_vars(names(l), !!(enquo(which)))
  l &lt;- as.list(l)[vars]
  l &lt;- lapply(l, function(x) {x*factor})
  xx &lt;- log(factor, 10)[2] - log(factor, 10)[1]
  len &lt;- length(vars)
  X &lt;- matrix(runif(len * length(l)*n*2), ncol = len)
  Y &lt;- matrix(runif(len * length(l)*n*2), ncol = len)
  for(i in seq(len)){
    X[,i] &lt;- l[[i]][[1]] * 10^(X[,i] * xx)
    Y[,i] &lt;- l[[i]][[1]] * 10^(Y[,i] * xx)
    colnames(X) &lt;- colnames(Y) &lt;- vars 
  }
  return(list(x1 = as.data.frame(X), x2 = as.data.frame(Y)))
}</code></pre>
<p>Instead of the log-transformed parameter sampling, I further used <a href="https://en.wikipedia.org/wiki/Quasi-Monte_Carlo_method">quasi-Monte Carlo method</a> (QMC) in the second new function. Generally, this method can create a relative uniformly parameter condition than the random method. Let’s call this function as <code>gen_samples_2()</code>.</p>
<pre class="r"><code>gen_samples_2 &lt;- function(n, l, which = names(l), factor = c(0.01,100)) {
  vars &lt;- select_vars(names(l), !!(enquo(which)))
  l &lt;- as.list(l)[vars]
  l &lt;- lapply(l, function(x) {x*factor})
  xx &lt;- log(factor, 10)[2] - log(factor, 10)[1]
  len &lt;- length(vars)
  
  X &lt;- sobol(n = length(l)*n*2, dim = 5)
  Y &lt;- sobol(n = length(l)*n*2, dim = 5, seed = 2345, scrambling = 3)
  
  for(i in seq(len)){
    X[,i] &lt;- l[[i]][[1]] * 10^(X[,i] * xx)
    Y[,i] &lt;- l[[i]][[1]] * 10^(Y[,i] * xx)
    colnames(X) &lt;- colnames(Y) &lt;- vars 
  }
  return(list(x1 = as.data.frame(X), x2 = as.data.frame(Y)))
}</code></pre>
</div>
<div id="convergence-analysis" class="section level2">
<h2>Convergence analysis</h2>
<p>This is one of the critical steps in the sensitivity analysis. More details can be found in my published paper in <a href="https://www.frontiersin.org/articles/10.3389/fphar.2018.00588/full">Frontiers in Pharmacology</a>. Here I create a function called <code>sample_converge()</code>, which can generate the convergence index based on the values of the given sample number. The drawback of this function is time-consuming. Because it estimates the convergence index at each sample number and each defined sampling function.</p>
<pre class="r"><code>sample_converge &lt;- function(n, l, which = names(l)){
  vars &lt;- select_vars(names(l), !!(enquo(which)))
  m &lt;- matrix(NA, length(n), length(vars))
  colnames(m) &lt;- vars
  rownames(m) &lt;- n
  m2 &lt;- m1 &lt;- m
  for (i in seq(length(n))){
    samp &lt;- gen_samples(n[i], l, names(vars))
    samp1 &lt;- gen_samples_1(n[i], l, names(vars))
    samp2 &lt;- gen_samples_2(n[i], l, names(vars))
    x &lt;- sobol2007(batch_run, X1=samp$x1, X2=samp$x2, nboot=100)
    x1 &lt;- sobol2007(batch_run, X1=samp1$x1, X2=samp1$x2, nboot=100)
    x2 &lt;- sobol2007(batch_run, X1=samp2$x1, X2=samp2$x2, nboot=100)
    m[i,] &lt;- x$T[,&quot;max. c.i.&quot;] - x$T[,&quot;min. c.i.&quot;]
    m1[i,] &lt;- x1$T[,&quot;max. c.i.&quot;] - x1$T[,&quot;min. c.i.&quot;]
    m2[i,] &lt;- x2$T[,&quot;max. c.i.&quot;] - x2$T[,&quot;min. c.i.&quot;]
  } 
  X &lt;- list(MC = m, log_MC = m1, log_QMC = m2)
  m %&gt;% melt()
  
  return(X)
}</code></pre>
</div>
</div>
<div id="results-1" class="section level1">
<h1>Results</h1>
<p>The first step in this section is using three defined functions to generate the testing parameter sets. The sampling number is 1000 for 5 parameters of TVCL, TVVC, TVKA, TVQ, and TVVP.</p>
<pre class="r"><code>set.seed(88771) 
samp &lt;- gen_samples(1000, param(mod), TVCL:TVVP)
set.seed(88771)
samp1 &lt;- gen_samples_1(1000, param(mod), TVCL:TVVP)
set.seed(88771)
samp2 &lt;- gen_samples_2(1000, param(mod), TVCL:TVVP)</code></pre>
<pre class="r"><code>head(samp$x1)</code></pre>
<pre><code>##       TVCL      TVVC      TVKA      TVQ      TVVP
## 1 2837.253  60942.57  7.963136 630.0039 22292.148
## 2 3490.800 149720.94 16.074012 622.5430 39757.169
## 3 2097.291  76185.77  9.419697 437.3082 45357.035
## 4 2341.387 201251.22  8.195339 541.6590  3983.256
## 5 5119.695 194035.06  9.592385 537.6485 48321.379
## 6 3456.046 137630.27 15.524459 414.2905 28568.707</code></pre>
<pre class="r"><code>head(samp1$x1)</code></pre>
<pre><code>##         TVCL        TVVC        TVKA          TVQ       TVVP
## 1   80.36703 33720.83858  0.03094521   0.11342304   250.5507
## 2  256.92007  1827.45564  1.73818471  24.59140377 11556.6357
## 3   21.55864  8151.36009  0.06179910   3.33735150   498.5483
## 4   33.27604  5318.35487 18.01243794   0.07733231   279.5965
## 5 4653.26263    23.78396 12.98278679 107.06337123   540.9213
## 6  241.52275 25146.74462  1.00422814   5.67155925  8914.3863</code></pre>
<pre class="r"><code>head(samp2$x1)</code></pre>
<pre><code>##        TVCL        TVVC        TVKA        TVQ        TVVP
## 1   51.8000  2030.00000 0.195000000  7.2200000   583.00000
## 2  518.0000   203.00000 1.950000000  0.7220000  5830.00000
## 3    5.1800 20300.00000 0.019500000 72.2000000    58.30000
## 4   16.3806   641.94237 0.616644144  0.2283164 18436.07876
## 5 1638.0598 64194.23650 0.006166441 22.8316447   184.36079
## 6  163.8060    64.19424 0.061664414  2.2831645    18.43608</code></pre>
<p>We can check the range of TVCL.</p>
<pre class="r"><code>i &lt;- &quot;TVCL&quot;</code></pre>
<pre class="r"><code>range(samp$x1[,i])</code></pre>
<pre><code>## [1]    1.395682 5179.881030</code></pre>
<pre class="r"><code>range(samp1$x1[,i])</code></pre>
<pre><code>## [1]    0.5188091 5178.9042539</code></pre>
<pre class="r"><code>range(samp2$x1[,i])</code></pre>
<pre><code>## [1]    0.5185827 5174.1793514</code></pre>
<p>The probability distributions of TVCL look like this.</p>
<pre class="r"><code>par(mfrow = c(3,2), mar = c(2,2,1,1))
samp$x1[,i] %&gt;% density() %&gt;% plot(main = &quot;MC&quot;)
samp1$x1[,i] %&gt;% density() %&gt;% plot(main = &quot;Log MC&quot;)
samp1$x1[,i] %&gt;% log(10) %&gt;% density() %&gt;% plot(main = &quot;Log MC&quot;)
samp2$x1[,i] %&gt;% log(10) %&gt;% density() %&gt;% plot(main = &quot;Log QMC&quot;)
samp$x1[,i] %&gt;% log(10) %&gt;% density() %&gt;% plot(main = &quot;MC&quot;)</code></pre>
<p><img src="/post/2019-02-08-sobol-sensitivity-analysis/index_files/figure-html/unnamed-chunk-21-1.png" width="672" /></p>
<p>Although the sampling ranges are nearly the same, we can easily understand how different sampling methods that cause the difference of parameter sampling result.</p>
<pre class="r"><code>j &lt;- &quot;TVKA&quot;
par(mfrow = c(3,2), mar = c(2,2,4,1))
heatscatter(samp$x1[,i], samp$x1[,j], add.contour=T, 
            nlevels=3, xlab = i, ylab = j, main = &quot;MC&quot;)
heatscatter(samp1$x1[,i], samp1$x1[,j], add.contour=T,
            nlevels=3, xlab = i, ylab = j, main = &quot;Log MC&quot;)
heatscatter(log(samp1$x1[,i]), log(samp1$x1[,j]), add.contour=T,
            nlevels=3, xlab = i, ylab = j, main = &quot;Log MC&quot;)
heatscatter(log(samp2$x1[,i]), log(samp2$x1[,j]), add.contour=T,
            nlevels=3, xlab = i, ylab = j, main = &quot;Log QMC&quot;)
heatscatter(log(samp$x1[,i]), log(samp$x1[,j]), add.contour=T,
            nlevels=3, xlab = i, ylab = j, main = &quot;MC&quot;)</code></pre>
<p><img src="/post/2019-02-08-sobol-sensitivity-analysis/index_files/figure-html/unnamed-chunk-22-1.png" width="672" /></p>
<p>Here, we can find the devil in detail. The uniform sampling in the parameter range without log-transformed ignores the lowest range of value that might cause bias in sampling.</p>
<div id="sobol-sensitivity-analysis-1" class="section level2">
<h2>Sobol sensitivity analysis</h2>
<p>Now, let’s run <code>Sobol2007()</code> with sampling parameter sets that were generated above</p>
<pre class="r"><code>x &lt;- sobol2007(batch_run, X1=samp$x1, X2=samp$x2, nboot=100)
x1 &lt;- sobol2007(batch_run, X1=samp1$x1, X2=samp1$x2, nboot=100)
x2 &lt;- sobol2007(batch_run, X1=samp2$x1, X2=samp2$x2, nboot=100)</code></pre>
<p>Print result</p>
<pre class="r"><code>x</code></pre>
<pre><code>## 
## Call:
## sobol2007(model = batch_run, X1 = samp$x1, X2 = samp$x2, nboot = 100)
## 
## Model runs: 70000 
## 
## First order indices:
##          original          bias  std. error     min. c.i.   max. c.i.
## TVCL 0.1578766813  3.250022e-03 0.033005767  0.0831340971 0.208784945
## TVVC 0.3447385309  8.297948e-03 0.058385061  0.2116874512 0.439716478
## TVKA 0.0024763449  1.134024e-04 0.001395324 -0.0006966283 0.004475360
## TVQ  0.0006193458  1.030277e-05 0.003931364 -0.0082013704 0.007769471
## TVVP 0.0014283420 -1.568393e-04 0.002094409 -0.0029347135 0.005404179
## 
## Total indices:
##          original          bias std. error   min. c.i.  max. c.i.
## TVCL  0.672686672 -0.0059100925 0.04348816  0.60216947 0.77544255
## TVVC  0.879711964 -0.0023144031 0.02527204  0.83348425 0.93344461
## TVKA -0.002296679  0.0003929362 0.00609826 -0.01654166 0.00753213
## TVQ   0.090611733 -0.0043982793 0.04320352  0.01043012 0.17826769
## TVVP -0.017351498 -0.0005199410 0.03743392 -0.08840910 0.07573544</code></pre>
<pre class="r"><code>x1</code></pre>
<pre><code>## 
## Call:
## sobol2007(model = batch_run, X1 = samp1$x1, X2 = samp1$x2, nboot = 100)
## 
## Model runs: 70000 
## 
## First order indices:
##         original          bias  std. error     min. c.i.  max. c.i.
## TVCL 0.112745680 -0.0018874736 0.021582893  0.0667614621 0.14906761
## TVVC 0.182459668  0.0022066883 0.029547809  0.1126664154 0.23557963
## TVKA 0.021922824  0.0001354410 0.004531145  0.0107957910 0.02909251
## TVQ  0.023164323  0.0017545308 0.008545537  0.0005484498 0.03525311
## TVVP 0.002536912  0.0007573005 0.008796247 -0.0135753283 0.02221676
## 
## Total indices:
##        original          bias std. error  min. c.i. max. c.i.
## TVCL 0.71060891 -3.411062e-04 0.03015394 0.65364477 0.7744247
## TVVC 0.72747952 -6.774622e-03 0.03716421 0.67285885 0.8337374
## TVKA 0.32450192 -6.844519e-03 0.03941054 0.25251174 0.4119687
## TVQ  0.24375109  5.215198e-05 0.04065983 0.15330960 0.3209390
## TVVP 0.08803744 -2.040679e-03 0.02449453 0.03902242 0.1323451</code></pre>
<pre class="r"><code>x2</code></pre>
<pre><code>## 
## Call:
## sobol2007(model = batch_run, X1 = samp2$x1, X2 = samp2$x2, nboot = 100)
## 
## Model runs: 70000 
## 
## First order indices:
##         original          bias  std. error    min. c.i.  max. c.i.
## TVCL 0.103027957  1.329474e-03 0.016928092  0.062206744 0.13392310
## TVVC 0.108067943  4.850138e-04 0.017032442  0.067234051 0.13681107
## TVKA 0.026631543 -1.896882e-04 0.006256774  0.012587506 0.03674231
## TVQ  0.022702256 -7.581687e-05 0.010309681 -0.002974256 0.03819241
## TVVP 0.002593369  1.097495e-03 0.007197813 -0.014341987 0.01483385
## 
## Total indices:
##       original         bias std. error  min. c.i. max. c.i.
## TVCL 0.6939626 -0.005988046 0.03177676 0.64003307 0.7667221
## TVVC 0.7600239 -0.003652923 0.03244894 0.70463123 0.8348733
## TVKA 0.2916849 -0.002200904 0.03767825 0.21765965 0.3703749
## TVQ  0.2299604  0.001193074 0.03354570 0.15617823 0.2964697
## TVVP 0.0951044  0.001477643 0.02077172 0.04920617 0.1352185</code></pre>
<p>Plot</p>
<pre class="r"><code>par(mfrow = c(2,2), mar = c(2,2,3,1))
plot(x, main = &quot;MC&quot;)
plot(x1, main = &quot;Log MC&quot;)
plot(x2, main = &quot;Log QMC&quot;)</code></pre>
<p><img src="/post/2019-02-08-sobol-sensitivity-analysis/index_files/figure-html/unnamed-chunk-25-1.png" width="672" /></p>
<p>Same as above, we can find that only TVCL and TVVC have an obvious influence on the model output in the previous sampling method. However, the proposed methods can easily rank the importance of parameters in this case.</p>
<p>The results of the parameter vs. model output look like this.</p>
<pre class="r"><code>par(mfrow = c(3,2), mar = c(2,2,4,1))
for (i in 1:5){
  heatscatter(log(x$X[,i]), log(x$y), xlab = &quot;&quot;, ylab = &quot;&quot;, main = names(x$X)[i])
}</code></pre>
<p><img src="/post/2019-02-08-sobol-sensitivity-analysis/index_files/figure-html/unnamed-chunk-26-1.png" width="672" /></p>
<p>This is the result of sampling in the log-transformed parameter range.</p>
<pre class="r"><code>par(mfrow = c(3,2), mar = c(2,2,4,1))
for (i in 1:5){
  heatscatter(log(x1$X[,i]), log(x1$y), xlab = &quot;&quot;, ylab = &quot;&quot;, main = names(x1$X)[i])
}</code></pre>
<p><img src="/post/2019-02-08-sobol-sensitivity-analysis/index_files/figure-html/unnamed-chunk-27-1.png" width="672" /></p>
<p>It’s an efficient way to see the relationship between parameter value and model output. The high impact parameter has a relatively concentrated contour than other parameters.</p>
</div>
<div id="convergence-assessment" class="section level2">
<h2>Convergence assessment</h2>
<p>The convergence index can simply calculate through the 95% CI of sensitivity index that is estimated from bootstrapping in the Sobol method. Here is the result of the convergence index under the sample number of 1000 from the above section.</p>
<pre class="r"><code>x$T[,&quot;max. c.i.&quot;] - x$T[,&quot;min. c.i.&quot;]</code></pre>
<pre><code>## [1] 0.17327308 0.09996036 0.02407379 0.16783757 0.16414454</code></pre>
<pre class="r"><code>x1$T[,&quot;max. c.i.&quot;] - x1$T[,&quot;min. c.i.&quot;]</code></pre>
<pre><code>## [1] 0.12077997 0.16087857 0.15945694 0.16762939 0.09332266</code></pre>
<pre class="r"><code>x2$T[,&quot;max. c.i.&quot;] - x2$T[,&quot;min. c.i.&quot;]</code></pre>
<pre><code>## [1] 0.12668908 0.13024203 0.15271526 0.14029143 0.08601233</code></pre>
<p>In this part, the values of the sample number were set at 500, 1000, 2000, 4000, and 8000. It will take a couple of minutes to run <code>sample_converge()</code></p>
<pre class="r"><code>sample &lt;- c(500, 1000, 2000, 4000, 8000)
set.seed(88771)
system.time(converge_list &lt;- sample_converge(sample, param(mod), TVCL:TVVP))</code></pre>
<pre><code>##    user  system elapsed 
##  315.27    4.40  320.00</code></pre>
<pre class="r"><code>df &lt;- do.call(rbind, list(converge_list[[1]] %&gt;% melt() %&gt;% cbind(type = &quot;MC&quot;),
                          converge_list[[2]] %&gt;% melt() %&gt;% cbind(type = &quot;log_MC&quot;),
                          converge_list[[3]] %&gt;% melt() %&gt;% cbind(type = &quot;log_QMC&quot;)))</code></pre>
<p>Finally, visualizing the result to see the convergence of each parameter. Both QMC and MC random sampling showed a similar result. Each parameter was close or below the threshold of 0.05. However, it’s hard to conclude that the QMC can provide the best way for Sobol sensitivity analysis in pharmacokinetic modeling.</p>
<pre class="r"><code>theme_set(theme_light())
df %&gt;% `colnames&lt;-`(c(&quot;sample.no&quot;, &quot;parameter&quot;, &quot;index&quot;, &quot;type&quot;)) %&gt;%
  ggplot(aes(sample.no, index, group = parameter)) + 
  geom_line(aes(color = parameter)) + 
  facet_wrap(~type) + 
  expand_limits(y= c(0, 0.5)) + 
  geom_hline(yintercept = 0.05, linetype=&quot;dashed&quot;, size = 0.2) +
  labs(y = &quot;Convergence index&quot;, x = &quot;Sample number&quot;) +
  theme(legend.position = &quot;top&quot;)</code></pre>
<p><img src="/post/2019-02-08-sobol-sensitivity-analysis/index_files/figure-html/unnamed-chunk-31-1.png" width="672" /></p>
</div>
</div>
<div id="take-away" class="section level1">
<h1>Take away</h1>
<ol style="list-style-type: decimal">
<li><p>Always plot the data. Because the devil might in the detail and your data might look likes a dinosaur.</p></li>
<li><p>Rethinking about the sampling. If the sampling range is too wide, try using the log-transformed method.</p></li>
<li><p>Finally, try Quasi-Monte Carlo. The QMC method can generate distribution than random MC sampling uniformly. Unfortunately, QMC didn’t show the best result in convergence assessment in this case.</p></li>
</ol>
</div>
<div id="session-info" class="section level1">
<h1>Session info</h1>
<pre class="r"><code>sessionInfo()</code></pre>
<pre><code>## R version 3.6.2 (2019-12-12)
## Platform: x86_64-w64-mingw32/x64 (64-bit)
## Running under: Windows 10 x64 (build 17763)
## 
## Matrix products: default
## 
## locale:
## [1] LC_COLLATE=English_United States.1252 
## [2] LC_CTYPE=English_United States.1252   
## [3] LC_MONETARY=English_United States.1252
## [4] LC_NUMERIC=C                          
## [5] LC_TIME=English_United States.1252    
## 
## attached base packages:
## [1] stats     graphics  grDevices utils     datasets  methods   base     
## 
## other attached packages:
##  [1] LSD_4.0-0          reshape2_1.4.3     randtoolbox_1.30.0 rngWELL_0.10-5    
##  [5] sensitivity_1.16.3 PKPDmisc_2.1.1     mrgsolve_0.10.0    forcats_0.4.0     
##  [9] stringr_1.4.0      dplyr_0.8.3        purrr_0.3.3        readr_1.3.1       
## [13] tidyr_1.0.0        tibble_2.1.3       ggplot2_3.2.1      tidyverse_1.3.0   
## 
## loaded via a namespace (and not attached):
##  [1] Rcpp_1.0.3                lubridate_1.7.4          
##  [3] lattice_0.20-38           prettyunits_1.0.2        
##  [5] ps_1.3.0                  assertthat_0.2.1         
##  [7] zeallot_0.1.0             digest_0.6.23            
##  [9] plyr_1.8.5                R6_2.4.1                 
## [11] cellranger_1.1.0          backports_1.1.5          
## [13] reprex_0.3.0              evaluate_0.14            
## [15] httr_1.4.1                blogdown_0.17            
## [17] pillar_1.4.2              rlang_0.4.2              
## [19] lazyeval_0.2.2            readxl_1.3.1             
## [21] rstudioapi_0.10           callr_3.4.0              
## [23] rmarkdown_2.0             labeling_0.3             
## [25] munsell_0.5.0             broom_0.5.2              
## [27] compiler_3.6.2            modelr_0.1.5             
## [29] xfun_0.11                 pkgconfig_2.0.3          
## [31] pkgbuild_1.0.6            htmltools_0.4.0          
## [33] tidyselect_0.2.5          bookdown_0.16            
## [35] fansi_0.4.0               crayon_1.3.4             
## [37] dbplyr_1.4.2              withr_2.1.2              
## [39] grid_3.6.2                nlme_3.1-142             
## [41] jsonlite_1.6              gtable_0.3.0             
## [43] lifecycle_0.1.0           DBI_1.0.0                
## [45] magrittr_1.5              scales_1.1.0             
## [47] cli_2.0.0                 stringi_1.4.3            
## [49] farver_2.0.1              fs_1.3.1                 
## [51] RcppArmadillo_0.9.800.3.0 xml2_1.2.2               
## [53] generics_0.0.2            vctrs_0.2.0              
## [55] boot_1.3-23               tools_3.6.2              
## [57] glue_1.3.1                hms_0.5.2                
## [59] processx_3.4.1            yaml_2.2.0               
## [61] colorspace_1.4-1          sessioninfo_1.1.1        
## [63] rvest_0.3.5               knitr_1.26               
## [65] haven_2.2.0</code></pre>
</div>
