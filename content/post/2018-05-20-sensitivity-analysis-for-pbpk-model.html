---
title: Sensitivity Analysis for PBPK model
summary: Applying the Morris screening method to exam the parameter sensitivity in physiological-based pharmacokinetic model
author: Nan-Hung Hsieh
date: '2018-05-20'
slug: sensitivity-analysis-for-pbpk-model
categories: []
math: true
tags:
  - sensitivity
  - R
  - ODE
  - desolve
  - PBPK
---



<p>In my previous post, I used python <a href="https://nanhung.rbind.io/post/sensitivity-analysis-by-python-salib/"><strong>SALib</strong></a> to conduct the sensitivity analysis for the simple example (Sobol model). Now, I want to take the more complicated case to understand how to apply sensitivity analysis in a dynamic model. Let’s get started!</p>
<p>I found an excellent example of the dynamic model, the physiological-based pharmacokinetic (PBPK) model provided from the book <a href="https://www.springer.com/la/book/9781493936076"><em>In silico Methods for Predicting Drug Toxicity</em></a> (chapter 3). This model was used to simulate the time-course of the concentration for the 1, 3-Butadiene in human body fluids and organs. The authors also provided the R source code to conduct the reproducible PBPK modeling.</p>
<p>I think this is an opportunity to apply the sensitivity analysis for this model. Therefore, I choose the elementary effect-based Morris screening method (<a href="https://www.tandfonline.com/doi/abs/10.1080/00401706.1991.10484804"><strong>Morris 1991</strong></a>), which is also the advance local sensitivity analysis that change one-factor-at-a-time (OAT) to investigate the parameter impact on the model output.</p>
<p>Compare with variance-based sensitivity analysis, the Morris method has high computing stable (lower computational cost) and only need few sample number (lower computational resource) to reach the convergence. However, there are some disadvantages for the local method, e.g., the percentage of the output variation cannot be quantified. Due to this PBPK case study is running in the pure R with the deSolve package. To have better computational performance, I think the Morris method is the best candidate.</p>
<p>The Morris method is an extension of the traditional OAT process, but over multiple points in the multi-dimensional parameter spaces as to provide global converge. For each parameter, the Morris approach can calculate the mean OAT sensitivities <span class="math inline">\(\mu\)</span> and its standard deviation <span class="math inline">\(\sigma\)</span>, which represent the overall influence and the interacts/non-linear effects on the model output, respectively.</p>
<p>An improved elementary effect method was developed by <a href="https://dl.acm.org/citation.cfm?id=1238207"><strong>Campolongo et al. (2007)</strong></a>. They improved both the reliability of the sensitivity measures (adding the mean absolute value of the OAT sensitives, denoted <span class="math inline">\(\mu^*\)</span>) as well as the efficiency of the sampling strategy (generating a large number of proposed sampling trajectories and selecting a subset with the highest diversion across parameter space).</p>
<div id="pbpk-modeling" class="section level1">
<h1>PBPK modeling</h1>
<p>Define and initialize the state variables. The used PBPK model was constructed from three tissue compartment (fat, well-perfused, and poorly-perfused tissues)</p>
<pre class="r"><code>y &lt;- c(&quot;Q_fat&quot; = 0, # Quantity of butadiene in fat (mg)
       &quot;Q_wp&quot; = 0, # ~ in well-perfused (mg)
       &quot;Q_pp&quot; = 0, # ~ in poorly-perfused (mg)
       &quot;Q_met&quot; = 0) # ~ metabolized (mg)</code></pre>
<p>Define the model parameters (Volumes: liter, Time: minute, Flows: liter / minute)</p>
<pre class="r"><code>parameters &lt;- c(&quot;BDM&quot; = 73, # Body mass (kg)
               &quot;Height&quot; = 1.6, # Body height (m)
               &quot;Age&quot; = 40, # in years
               &quot;Sex&quot; = 1, # code 1 is male, 2 is female
               &quot;Flow_pul&quot; = 5, # Pulmonary ventilation rate (L/min)
               &quot;Pct_Deadspace&quot; = 0.7, # Fraction of pulmonary deadspace
               &quot;Vent_Perf&quot; = 1.14, # Ventilation over perfusion ratio
               &quot;Pct_LBDM_wp&quot; = 0.2, # wp tissue as fraction of lean mass
               &quot;Pct_Flow_fat&quot; = 0.1, # Fraction of cardiac output to fat
               &quot;Pct_Flow_pp&quot; = 0.35, # ~ to pp
               &quot;PC_art&quot; = 2, # Blood/air partition coefficient
               &quot;PC_fat&quot; = 22, # Fat/blood ~
               &quot;PC_wp&quot; = 0.8, # wp/blood ~
               &quot;PC_pp&quot; = 0.8, # pp/blood ~
               &quot;Kmetwp&quot; = 0.25) # Rate constant for metabolism</code></pre>
<p>Define the exposure function. I set the periodic exposure (8-hour exposure per day) in a week.</p>
<pre class="r"><code>min_per_week &lt;- 60 * 24 * 7 

x1 &lt;- seq(1, min_per_week, 1440) # start exposure
x2 &lt;- seq(480, min_per_week, 1440) # stop exposure
duration &lt;- as.vector(matrix(c(x1, x2), nrow = 2, byrow = TRUE))
exposure &lt;- rep(c(10,0.1),length(duration)/2)
C_inh &lt;- approxfun(x = duration, y = exposure, method=&quot;constant&quot;, f=0, rule=2)

# Check the input concentration profile just defined
plot(C_inh(1:min_per_week), xlab = &quot;Time (min)&quot;,
     ylab = &quot;Butadiene air concentration (ppm)&quot;, type = &quot;l&quot;)</code></pre>
<p><img src="/post/2018-05-20-sensitivity-analysis-for-pbpk-model_files/figure-html/unnamed-chunk-3-1.png" width="672" /></p>
<p>Define the PBPK model</p>
<pre class="r"><code># Define the model equations
bd.model = function(t, y, parameters) {
  with (as.list(y), {
    with (as.list(parameters), {
      
      # Define the fixed parameters
      Height = 1.6
      Age = 40
      Sex = 1
      
      # Define some useful constants
      MW_bu = 54.0914 # butadiene molecular weight (in grams)
      ppm_per_mM = 24450 # ppm to mM under normal conditions
      # Conversions from/to ppm
      ppm_per_mg_per_l = ppm_per_mM / MW_bu
      mg_per_l_per_ppm = 1 / ppm_per_mg_per_l
      # Calculate Flow_alv from total pulmonary flow
      Flow_alv = Flow_pul * (1 - Pct_Deadspace)
      # Calculate total blood flow from Flow_alv and the V/P ratio
      Flow_tot = Flow_alv / Vent_Perf
      # Calculate fraction of body fat
      Pct_BDM_fat = (1.2 * BDM / (Height * Height) - 10.8
                     *(2 - Sex) +
                       0.23 * Age - 5.4) * 0.01
      # Actual volumes, 10% of body mass (bones…) get no butadiene
      Eff_V_fat = Pct_BDM_fat * BDM
      Eff_V_wp = Pct_LBDM_wp * BDM * (1 - Pct_BDM_fat)
      Eff_V_pp = 0.9 * BDM - Eff_V_fat - Eff_V_wp
      # Calculate actual blood flows from total flow and percent flows
      Flow_fat = Pct_Flow_fat * Flow_tot
      Flow_pp = Pct_Flow_pp * Flow_tot
      Flow_wp = Flow_tot * (1 - Pct_Flow_pp - Pct_Flow_fat)
      # Calculate the concentrations
      C_fat = Q_fat / Eff_V_fat
      C_wp = Q_wp / Eff_V_wp
      C_pp = Q_pp / Eff_V_pp
      # Venous blood concentrations at the organ exit
      Cout_fat = C_fat / PC_fat
      Cout_wp = C_wp / PC_wp
      Cout_pp = C_pp / PC_pp
      # Sum of Flow * Concentration for all compartments
      dQ_ven = Flow_fat * Cout_fat + Flow_wp * Cout_wp + Flow_pp * Cout_pp
      C_inh.current = C_inh(t) # to avoid calling C_inh() twice
      # Arterial blood concentration
      # Convert input given in ppm to mg/l to match other units
      C_art = (Flow_alv * C_inh.current * mg_per_l_per_ppm + dQ_ven) / (Flow_tot + Flow_alv / PC_art)
      # Venous blood concentration (mg/L)
      C_ven = dQ_ven / Flow_tot
      # Alveolar air concentration (mg/L)
      C_alv = C_art / PC_art
      # Exhaled air concentration (ppm!)
      if (C_alv &lt;= 0) {
        C_exh = 10E-30 # avoid round off errors
      } else {
        C_exh = (1 - Pct_Deadspace) * C_alv * ppm_per_mg_per_l +
          Pct_Deadspace * C_inh.current
      }
      # Quantity metabolized in liver (included in well-perfused)
      dQmet_wp = Kmetwp * Q_wp
      # Differentials for quantities
      dQ_fat = Flow_fat * (C_art - Cout_fat)
      dQ_wp = Flow_wp * (C_art - Cout_wp) - dQmet_wp
      dQ_pp = Flow_pp * (C_art - Cout_pp)
      dQ_met = dQmet_wp
      # The function bd.model must return at least the derivatives
      list(c(dQ_fat, dQ_wp, dQ_pp, dQ_met), # derivatives
           c(&quot;C_ven&quot; = C_ven, &quot;C_art&quot; = C_art)) # extra outputs
    }) # end with parameters
  }) # end with y
} # end bd.model</code></pre>
<p>Define the computation output times and call the ODE solver</p>
<pre class="r"><code>library(deSolve)
times &lt;- seq(from = 0, to = min_per_week, by = 10) # A week
results &lt;- ode(times = times, func = bd.model, y = y, parms = parameters)</code></pre>
<p>Plot the results of the simulation</p>
<pre class="r"><code>plot(results, col=&quot;red&quot;)</code></pre>
<p><img src="/post/2018-05-20-sensitivity-analysis-for-pbpk-model_files/figure-html/unnamed-chunk-6-1.png" width="672" /></p>
</div>
<div id="sensitivity-analysis" class="section level1">
<h1>Sensitivity analysis</h1>
<p>Firstly, we use the Morris method which was provided from <code>sensitivity</code> package.</p>
<pre class="r"><code>library(sensitivity)</code></pre>
<p>Define the testing parameters. Twelve parameters were used in this test.</p>
<pre class="r"><code>factors &lt;- c(&quot;BDM&quot;, &quot;Flow_pul&quot;, &quot;Pct_Deadspace&quot;, &quot;Vent_Perf&quot;, 
             &quot;Pct_LBDM_wp&quot;, &quot;Pct_Flow_fat&quot;, &quot;Pct_Flow_pp&quot;, 
             &quot;PC_art&quot;, &quot;PC_fat&quot;, &quot;PC_wp&quot;, &quot;PC_pp&quot;,
             &quot;Kmetwp&quot;)</code></pre>
<p>Then, we need to set up the uncertainty for each parameter. Here we set the 10% variation in the testing parameters.</p>
<pre class="r"><code>LL &lt;- 0.9 # 10% lower limit
UL &lt;- 1.1 # 10% upper limit

# Define the lower and upper limits that will be the input to the morris function
binf &lt;- c(parameters[&quot;BDM&quot;]*LL, 
          parameters[&quot;Flow_pul&quot;]*LL,
          parameters[&quot;Pct_Deadspace&quot;]*LL,
          parameters[&quot;Vent_Perf&quot;]*LL,
          parameters[&quot;Pct_LBDM_wp&quot;]*LL,
          parameters[&quot;Pct_Flow_fat&quot;]*LL,
          parameters[&quot;Pct_Flow_pp&quot;]*LL,
          parameters[&quot;PC_art&quot;]*LL,
          parameters[&quot;PC_fat&quot;]*LL,
          parameters[&quot;PC_wp&quot;]*LL,
          parameters[&quot;PC_pp&quot;]*LL,
          parameters[&quot;Kmetwp&quot;]*LL)
bsup &lt;- c(parameters[&quot;BDM&quot;]*UL, 
          parameters[&quot;Flow_pul&quot;]*UL,
          parameters[&quot;Pct_Deadspace&quot;]*UL,
          parameters[&quot;Vent_Perf&quot;]*UL,
          parameters[&quot;Pct_LBDM_wp&quot;]*UL,
          parameters[&quot;Pct_Flow_fat&quot;]*UL,
          parameters[&quot;Pct_Flow_pp&quot;]*UL,
          parameters[&quot;PC_art&quot;]*UL,
          parameters[&quot;PC_fat&quot;]*UL,
          parameters[&quot;PC_wp&quot;]*UL,
          parameters[&quot;PC_pp&quot;]*UL,
          parameters[&quot;Kmetwp&quot;]*UL)</code></pre>
<p>To check the convergence of the sensitivity index, we can set up the sequence of the sampling number. After that, we can apply the for-loop to do the morris sensitivity analysis and link with numerical analysis with deSolve::ode function. In this case, I examine the parameter sensitivity under the exposure time at 8-hour (stop point of the first exposure) and investigate the parameter sensitivity. Also, we only focused on the parameter effect on venous blood concentration.</p>
<pre class="r"><code>sample &lt;- seq(from = 20, to = 140, by = 20)

for (i in 1:length(sample)) {
  set.seed(12345)
  x &lt;- morris(model = NULL, factors = factors, r = sample[i],
              design = list(type = &quot;oat&quot;, levels = 6, grid.jump = 3), 
              binf = binf, bsup = bsup, scale = TRUE)
  
  for (iteration in 1:nrow(x$X)) { 
    
    parameters[&quot;BDM&quot;] = x$X[iteration,&quot;BDM&quot;]
    parameters[&quot;Flow_pul&quot;] = x$X[iteration,&quot;Flow_pul&quot;]
    parameters[&quot;Pct_Deadspace&quot;] = x$X[iteration,&quot;Pct_Deadspace&quot;]
    parameters[&quot;Vent_Perf&quot;] = x$X[iteration,&quot;Vent_Perf&quot;]
    parameters[&quot;Pct_LBDM_wp&quot;] = x$X[iteration,&quot;Pct_LBDM_wp&quot;]
    parameters[&quot;Pct_Flow_fat&quot;] = x$X[iteration,&quot;Pct_Flow_fat&quot;]
    parameters[&quot;Pct_Flow_pp&quot;] = x$X[iteration,&quot;Pct_Flow_pp&quot;]
    parameters[&quot;PC_art&quot;] = x$X[iteration,&quot;PC_art&quot;]
    parameters[&quot;PC_fat&quot;] = x$X[iteration,&quot;PC_fat&quot;]
    parameters[&quot;PC_wp&quot;] = x$X[iteration,&quot;PC_wp&quot;]
    parameters[&quot;PC_pp&quot;] = x$X[iteration,&quot;PC_pp&quot;]
    parameters[&quot;Kmetwp&quot;] = x$X[iteration,&quot;Kmetwp&quot;]
    
    # We focus on time at 8 hour (stop exposure),
    times = c(0, 480)
    # Integrate
    tmp = ode(times = times, func = bd.model, y = y, parms = parameters)
    if (iteration == 1) { # initialize
      results = tmp[2,-1]
      sampled.parms = c(parameters[&quot;BDM&quot;], 
                        parameters[&quot;Flow_pul&quot;],
                        parameters[&quot;Pct_Deadspace&quot;],
                        parameters[&quot;Vent_Perf&quot;],
                        parameters[&quot;Pct_LBDM_wp&quot;],
                        parameters[&quot;Pct_Flow_fat&quot;],
                        parameters[&quot;Pct_Flow_pp&quot;],
                        parameters[&quot;PC_art&quot;],
                        parameters[&quot;PC_fat&quot;],
                        parameters[&quot;PC_wp&quot;],
                        parameters[&quot;PC_pp&quot;],
                        parameters[&quot;Kmetwp&quot;])
    } else { # accumulate
      results = rbind(results, tmp[2,-1])
      sampled.parms = rbind(sampled.parms,
                            c(parameters[&quot;BDM&quot;], 
                              parameters[&quot;Flow_pul&quot;],
                              parameters[&quot;Pct_Deadspace&quot;],
                              parameters[&quot;Vent_Perf&quot;],
                              parameters[&quot;Pct_LBDM_wp&quot;],
                              parameters[&quot;Pct_Flow_fat&quot;],
                              parameters[&quot;Pct_Flow_pp&quot;],
                              parameters[&quot;PC_art&quot;],
                              parameters[&quot;PC_fat&quot;],
                              parameters[&quot;PC_wp&quot;],
                              parameters[&quot;PC_pp&quot;],
                              parameters[&quot;Kmetwp&quot;]))
    }
  }
  
  # 
  tell(x, results[,&quot;C_ven&quot;]) # We focus on parameter effect on venous blood concentration
  
  if (i == 1){
    X &lt;- apply(abs(x$ee), 2, mean)  
  } else {
    X &lt;- rbind(X, apply(abs(x$ee), 2, mean))
  }
}</code></pre>
<div id="number-of-repetitions-and-parameter-sensitivity" class="section level2">
<h2>Number of repetitions and parameter sensitivity</h2>
<p>Through this plot, we can examine the variation and converge of the parameter. It seems that each sensitivity index of the parameter was stable across all sampling number. Also, we can find the fraction of pulmonary dead space is the most influential parameter.</p>
<pre class="r"><code># Manipulate the output result for plotting
row.names(X) &lt;- sample
meltX &lt;- reshape::melt(X)
ee_lim &lt;- c(min(abs(x$ee)), max(abs(x$ee)))

library(viridis) # use viridis to create distinct colors </code></pre>
<pre><code>## Warning: package &#39;viridis&#39; was built under R version 3.4.4</code></pre>
<pre><code>## Loading required package: viridisLite</code></pre>
<pre><code>## Warning: package &#39;viridisLite&#39; was built under R version 3.4.3</code></pre>
<pre class="r"><code>par(mar=c(4,4,2,1))
plot(sample, subset(meltX, X2 == factors[1])[,3], type=&quot;b&quot;, col=viridis_pal()(12)[1],
     frame.plot = FALSE, 
     xlab=&quot;number of repetitions&quot;,
     ylab=expression(paste(mu,&quot;*&quot;)), ylim=ee_lim, xlim = c(20,160))
for( i in 2:12){
  lines(sample, subset(meltX, X2 == factors[i])[,3], type=&quot;b&quot;, col=viridis_pal()(12)[i])
}
text(140, subset(meltX, X1 == 140)[,3], factors, pos = 4)</code></pre>
<p><img src="/post/2018-05-20-sensitivity-analysis-for-pbpk-model_files/figure-html/unnamed-chunk-11-1.png" width="864" /></p>
</div>
<div id="mean-oat-sensitivities-and-standard-deviation" class="section level2">
<h2>Mean OAT sensitivities and standard deviation</h2>
<p>This visualization provides the information to examine the parameter sensitivity and the relationships between model parameters and its related output. According to the output result, we can find the relationship between the parameter values and model outputs are between linear and monotonic.</p>
<pre class="r"><code>plot(x, xlim=ee_lim, main =&quot;number of repetitions = 140&quot;)
abline(0,1) # non-linear and/or non-monotonic
abline(0,0.5, lty = 2) # monotonic
abline(0,0.1, lty = 3) # almost linear
legend(&quot;bottomright&quot;, legend = c(&quot;non-linear and/or non-monotonic&quot;,
                                 &quot;monotonic&quot;,
                                 &quot;almost linear&quot;), lty = c(1:3))</code></pre>
<p><img src="/post/2018-05-20-sensitivity-analysis-for-pbpk-model_files/figure-html/unnamed-chunk-12-1.png" width="672" /></p>
</div>
</div>
<div id="parameter-variation-and-model-output" class="section level1">
<h1>Parameter variation and model output</h1>
<p>To investigate the parameter effect on the PBPK model outputs, we used the following visualization methods for all parameters and most influential parameter (Pct_Deadspace) and less influential parameter (PC_pp).</p>
<p>For all parameters</p>
<pre class="r"><code>par(mfrow=c(3,4))
for (i in 1:12){
  plot(x$X[,i], x$y, main = x$factors[i], xlab = &quot;&quot;, ylab = &quot;predict conc.&quot;)
}</code></pre>
<p><img src="/post/2018-05-20-sensitivity-analysis-for-pbpk-model_files/figure-html/unnamed-chunk-13-1.png" width="672" /></p>
<p>For most influential parameter (Pct_Deadspace)</p>
<pre class="r"><code>library(ggplot2)
library(plyr)

sensiX &lt;- data.frame(x$X[,&quot;Pct_Deadspace&quot;], x$y)
names(sensiX) &lt;- c(&quot;Pct_Deadspace&quot;, &quot;Predict.conc&quot;)
musensi &lt;- ddply(sensiX, &quot;Pct_Deadspace&quot;, summarize, mean.conc=mean(Predict.conc))

ggplot(sensiX, aes(x=Predict.conc, color=as.factor(Pct_Deadspace))) +
  geom_density() + scale_color_discrete(name=&quot;Pct_Deadspace&quot;) +
  geom_vline(data=musensi, aes(xintercept=mean.conc, color=as.factor(Pct_Deadspace)),
             linetype=&quot;dashed&quot;) +
  theme_minimal()</code></pre>
<p><img src="/post/2018-05-20-sensitivity-analysis-for-pbpk-model_files/figure-html/unnamed-chunk-14-1.png" width="672" /></p>
<p>For less influential parameter (PC_pp)</p>
<pre class="r"><code>insensiX &lt;- data.frame(x$X[,&quot;PC_pp&quot;], x$y)
names(insensiX) &lt;- c(&quot;PC_pp&quot;, &quot;Predict.conc&quot;)
muinsensi &lt;- ddply(insensiX, &quot;PC_pp&quot;, summarize, mean.conc=mean(Predict.conc))

ggplot(insensiX, aes(x=Predict.conc, color=as.factor(PC_pp))) +
  geom_density() + scale_color_discrete(name=&quot;PC_pp&quot;) +
  geom_vline(data=muinsensi, aes(xintercept=mean.conc, color=as.factor(PC_pp)),
             linetype=&quot;dashed&quot;) +
  theme_minimal()</code></pre>
<p><img src="/post/2018-05-20-sensitivity-analysis-for-pbpk-model_files/figure-html/unnamed-chunk-15-1.png" width="672" /></p>
<p>Through this method, we can quickly check the parameter sensitivity in PBPK model and check the parameter effects on model output. However, this is just the simple test case. To do the “complete” sensitivity analysis, we still need to find the reasonable parameter uncertainty and its range. However, this step-by-step method can provide the essential information for beginners to apply the sensitivity in the dynamic model.</p>
</div>
